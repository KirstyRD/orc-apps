/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
package devel.org.sc29.wg11.mpegh.part2.main.Filters;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

actor GenerateBs()
	bool          Cbf,
	uint(size=16) CUInfo,
	uint(size=2)  IsBiPredOrLx,
	uint(size=8)  LcuSizeMax,
	uint(size=2)  LFAcrossSlcTile,
	int (size=32) Mv,
	uint(size=4)  PartMode,
	int (size=16) RefPoc,
	uint(size=16) SliceAddr,
	bool          SplitTransf,
	uint(size=16) TilesCoord
		==>
	uint(size=2) BS
		:

	uint(size=16) sliceAdr[2];
	bool loopFilterAcrossSlc;
	bool loopFilterAcrossTile;

	uint(size=8)  lcuSizeMax;
	uint(size=7)  nS;
	uint(size=16) cuAddr[2] := [-1,-1];
	uint(size=16) cuAddrNQT[2] := [-1,-1];
	uint(size=5)  cuMode;
	uint(size=3)  numPart;
	uint(size=3)  numPartDecoded;

	int (size=4) trafoTreeDepth;
	uint(size=3) trafoTreeIdx[6];

	bool vertEdgeFlagVal[16] :=
		[true, true, true, true, true, true, true, true, true, true, true,
		 true, true, true, true, true];
	bool horEdgeFlagVal[16]  :=
		[true, true, true, true, true, true, true, true, true, true, true,
		 true, true, true, true, true];

	int(size=16) iLoop;

	uint(size=16) numTiles;
	uint(size=16) currTileIdx;
	uint(size=16) tilesBeg[MAX_NUM_TILES][2];
	uint(size=16) tilesEnd[MAX_NUM_TILES][2];

	uint(size=5) predModeTab[PICT_WIDTH_POW_2/4][PICT_HEIGHT_POW_2/4];//
	bool cbfUpNeighb[PICT_WIDTH_POW_2/4];//
	bool cbfLeftNeighb[PICT_HEIGHT_POW_2/4];//
	bool isBiPredTab[PICT_WIDTH_POW_2/4][PICT_HEIGHT_POW_2/4];//
	int(size=16) refPocUpNeighb[PICT_WIDTH_POW_2/4][2];//
	int(size=16) refPocLeftNeighb[PICT_HEIGHT_POW_2/4][2];//
	int(size=32) mvUpNeighb[PICT_WIDTH_POW_2/4][2][2];//
	int(size=32) mvLeftNeighb[PICT_HEIGHT_POW_2/4][2][2];//
	int(size=16) coordMax1stPu[2];
	int(size=16) xMax1stPu;
	bool isBiPred[2];
	int(size=16) refPoc[2][2];
	//Clean the computation.
	int(size=32) mv[2][2][2];
	

	uint(size=9) currIdx;
	int(size=9) nbBlkToSend;
	uint(size=2) numMvInfo;
	uint(size=2) bsTable[2][256];

	procedure findCurrTile(uint(size=16) xPixAddr, uint(size=16) yPixAddr)
	begin
		foreach int tileIdx in 0 .. numTiles - 1
		do
			if(xPixAddr >= tilesBeg[tileIdx][0] &&
				xPixAddr < tilesEnd[tileIdx][0]) then
				if(yPixAddr >= tilesBeg[tileIdx][1] &&
					yPixAddr < tilesEnd[tileIdx][1]) then
					currTileIdx := tileIdx;
				end
			end
		end
	end

	procedure savePredInfo(uint(size=16) addr[2], uint(size=8) puSize[2],
		uint(size=1) tabIdx)
	var
		uint(size=16) xMin = (addr[0]>>2)&(PICT_WIDTH_POW_2/4-1),
		uint(size=16) xMax = ((addr[0]+puSize[0])/4)&(PICT_WIDTH_POW_2/4-1),
		uint(size=16) yMin = addr[1]/4,
		uint(size=16) yMax = (addr[1]+puSize[1])/4,
		uint(size=16) y
	begin
		foreach uint x in xMin .. xMax-1
		do
			y := yMin;
			while(y!=yMax)
			do
				predModeTab[x][y] := cuMode;
				isBiPredTab[x][y] := isBiPred[tabIdx];
				y := y+1;
			end
		end
	end

	procedure rstEdgeTables(uint(size=16) addr[2])
	begin
		vertEdgeFlagVal[0] := (addr[0] != 0);
		horEdgeFlagVal[0] := (addr[1] != 0);
	
		vertEdgeFlagVal[0] := not(addr[0]=0 ||
			(not loopFilterAcrossSlc &&
				sliceAdr[0]=addr[0] && sliceAdr[1]=addr[1]) ||
			 not loopFilterAcrossTile &&
				addr[0] = tilesBeg[currTileIdx][0]);
	
		if(addr[1]=0) then
			horEdgeFlagVal[0] := false;
		else
			if(not loopFilterAcrossSlc && (sliceAdr[1] = addr[1] ||
					(sliceAdr[1] + lcuSizeMax = addr[1] && addr[0] < sliceAdr[0]))) then
				horEdgeFlagVal[0] := false;
			elsif(not loopFilterAcrossTile &&
				addr[1] = tilesBeg[currTileIdx][1]) then
				horEdgeFlagVal[0] := false;
			else
				horEdgeFlagVal[0] := true;
			end
		end
	end

	procedure processTUBoundaries(bool cbf, uint(size=16) treeAddr[2], uint(size=7) treeNS)
	var
		uint(size=16) xMin,
		uint(size=16) xMax,
		uint(size=16) yMin,
		uint(size=16) yMax,

		uint(size=2) bS[1],
		uint(size=16) addrBlk[2],
		uint(size=16) addrTU[2],
		uint(size=16) rasterIdx,
		int(size=32) mvQ0Pu1 [2][2] := [[mv[0][i][j] - (cuAddr[j] << 2): for int j in 0 .. 1]: for int i in 0 .. 1],
		int(size=32) mvQ0Pu2 [2][2] := [[mv[1][i][j] - (cuAddrNQT[j] << 2): for int j in 0 .. 1]: for int i in 0 .. 1],
		int(size=16) refPocQ0Pu1[2] := [refPoc[0][i]: for int i in 0 .. 1],
		int(size=16) refPocQ0Pu2[2] := [refPoc[1][i]: for int i in 0 .. 1]
	begin
		xMin := (treeAddr[0] & (lcuSizeMax - 1))>>2;
		xMax := xMin+(treeNS>>2);
		yMin := (treeAddr[1] & (lcuSizeMax - 1))>>2;
		yMax := yMin + (treeNS>>2);

		if(horEdgeFlagVal[yMin]) then
			addrBlk := treeAddr;
			addrTU := [treeAddr[i] - cuAddr[i]: for int i in 0 .. 1];
			foreach int x in xMin .. xMax - 1
			do
				rasterIdx := absCoordToZScan(addrTU);
				if(x < coordMax1stPu[0] && yMin < coordMax1stPu[1]) then
					genBoundFilterStrength(bS, addrBlk, false, 0, true, cbf, mvQ0Pu1, refPocQ0Pu1);
				else
					genBoundFilterStrength(bS, addrBlk, false, 0, true, cbf, mvQ0Pu2, refPocQ0Pu2);
				end
				bsTable[1][rasterIdx] := bS[0];
				addrBlk[0] := addrBlk[0] + 4;
				addrTU[0] := addrTU[0] + 4;
			end
		end

		if(vertEdgeFlagVal[xMin]) then
			addrBlk := treeAddr;
			addrTU := [treeAddr[i] - cuAddr[i]: for int i in 0 .. 1];
			foreach int y in yMin .. yMax - 1
			do
				rasterIdx := absCoordToZScan(addrTU);
				if(xMin < coordMax1stPu[0] && y < coordMax1stPu[1]) then
					genBoundFilterStrength(bS, addrBlk, true, 0, true, cbf, mvQ0Pu1, refPocQ0Pu1);
				else
					genBoundFilterStrength(bS, addrBlk, true, 0, true, cbf, mvQ0Pu2, refPocQ0Pu2);
				end
				bsTable[0][rasterIdx] := bS[0];
				
				addrBlk[1] := addrBlk[1] + 4;
				addrTU[1] := addrTU[1] + 4;
			end
		end
	end

	/* Compute Pu boundary only if it's not sure to also have a TU boundary */
	procedure processPUBoundary(uint(size=16) addr[2], uint(size=8) puSize[2], bool edgeIsHoriz)
	var
		int xMin = (addr[0] & (lcuSizeMax - 1)) >> 2,
		int xMax = xMin + (puSize[0] >> 2),
		int yMin = (addr[1] & (lcuSizeMax - 1)) >> 2,
		int yMax = yMin + (puSize[1] >> 2),


		uint(size=2) bS[1],
		uint(size=16) addrBlk[2],
		uint(size=16) addrTU[2],
		uint(size=16) rasterIdx,
		int(size=32) mvQ0Pu1 [2][2] := [[mv[0][i][j] - (cuAddr[j] << 2): for int j in 0 .. 1]: for int i in 0 .. 1],
		int(size=32) mvQ0Pu2 [2][2] := [[mv[1][i][j] - (cuAddrNQT[j] << 2): for int j in 0 .. 1]: for int i in 0 .. 1],
		int(size=16) refPocQ0Pu1[2] := [refPoc[0][i]: for int i in 0 .. 1],
		int(size=16) refPocQ0Pu2[2] := [refPoc[1][i]: for int i in 0 .. 1]
	begin
		addrBlk := [addr[0], addr[1]];
		addrTU := [addr[i] - cuAddr[i]: for int i in 0 .. 1];
		if(edgeIsHoriz) then
			if(horEdgeFlagVal[yMin]) then
				foreach int x in xMin .. xMax - 1
				do
					rasterIdx := absCoordToZScan(addrTU);
					genBoundFilterStrengthCore(bS, addrBlk, false, 0, false, false, mvQ0Pu1, mvQ0Pu2, refPocQ0Pu1, refPocQ0Pu2);
					bsTable[1][rasterIdx] := bS[0];
					addrBlk[0] := addrBlk[0] + 4;
					addrTU[0] := addrTU[0] + 4;
				end
			end
		else
			if(vertEdgeFlagVal[xMin]) then
				foreach int y in yMin .. yMax - 1
				do
					rasterIdx := absCoordToZScan(addrTU);
					genBoundFilterStrengthCore(bS, addrBlk, true, 0, false, false, mvQ0Pu1, mvQ0Pu2, refPocQ0Pu1, refPocQ0Pu2);
					bsTable[0][rasterIdx] := bS[0];
					addrBlk[1] := addrBlk[1] + 4;
					addrTU[1] := addrTU[1] + 4;
				end
			end
		end
	end

	procedure genBoundFilterStrength(uint(size=2) bS[1], uint(size=16) addr[2],
		bool isVerticalEdge, uint(size=2) cIdx, bool isTUEdge, bool cbfQ0,
		int(size=32) mvQ0 [2][2], int(size=16) refPocQ0[2])
	var
		uint(size=16) q0[2] = [(addr[0]/4)&(PICT_WIDTH_POW_2/4-1), addr[1]/4],
		int(size=32) mvP0 [2][2] := if(isVerticalEdge) then
			[[mvLeftNeighb[q0[1]][i][j]: for int j in 0 .. 1]: for int i in 0 .. 1]
				else
			[[mvUpNeighb[q0[0]][i][j]: for int j in 0 .. 1]: for int i in 0 .. 1] end,
		int(size=16) refPocP0 [2] := if(isVerticalEdge) then
			[refPocLeftNeighb[q0[1]][i]: for int i in 0 .. 1]
				else
			[refPocUpNeighb[q0[0]][i]: for int i in 0 .. 1] end
	begin
		genBoundFilterStrengthCore(bS, addr, isVerticalEdge, cIdx, isTUEdge, cbfQ0, mvP0, mvQ0, refPocP0, refPocQ0);
	end

	procedure genBoundFilterStrengthCore(uint(size=2) bS[1], uint(size=16) addr[2],
		bool isVerticalEdge, uint(size=2) cIdx, bool isTUEdge, bool cbfQ0,
		int(size=32) mvP0 [2][2], int(size=32) mvQ0 [2][2], int(size=16) refPocP0[2], int(size=16) refPocQ0 [2])
	var
		uint(size=16) q0[2] = [(addr[0]/4)&(PICT_WIDTH_POW_2/4-1), addr[1]/4],
		uint(size=16) p0[2] := if(isVerticalEdge) then [q0[0]-1, q0[1]]
			else [q0[0], q0[1]-1] end,
		bool cbfP0 = if(isVerticalEdge) then cbfLeftNeighb[q0[1]] else cbfUpNeighb[q0[0]] end,
		int(size=16) tmpRefPoc,
		int(size=32) tmpMv,
		int(size=32) absMv[2][2],
		int(size=16) absMvQP[2][2]
	begin
		if(isVerticalEdge && ((addr[0]>>2)&1)=1) then
			bS[0] := 0;
		else if(not isVerticalEdge && ((addr[1]>>2)&1)=1) then
			bS[0] := 0;
		else if(predModeTab[p0[0]][p0[1]] = INTRA || predModeTab[q0[0]][q0[1]] = INTRA) then
			bS[0] := 2;
		else if(cIdx=0 && isTUEdge && (cbfP0 || cbfQ0)) then
			bS[0] := 1;
		else
			if(isBiPredTab[p0[0]][p0[1]] && isBiPredTab[q0[0]][q0[1]] && refPocP0[0] = refPocQ0[1] && 
				not(refPocP0[0] = refPocQ0[0] && mvP0[0][0] = mvQ0[0][0] &&
					mvP0[0][1] = mvQ0[0][1])) then
				tmpRefPoc := refPocP0[1];
				refPocP0[1] := refPocP0[0];
				refPocP0[0] := tmpRefPoc;

				tmpMv := mvP0[0][0];
				mvP0[0][0] := mvP0[1][0];
				mvP0[1][0] := tmpMv;

				tmpMv := mvP0[0][1];
				mvP0[0][1] := mvP0[1][1];
				mvP0[1][1] := tmpMv;

			end
			if(isBiPredTab[p0[0]][p0[1]] != isBiPredTab[q0[0]][q0[1]] ||
			   refPocP0[0] != refPocQ0[0] ||
			   isBiPredTab[p0[0]][p0[1]] && //L1
			   (refPocP0[1] != refPocQ0[1])) then
				bS[0] := 1;
			else
				absMv[0][0] := abs(mvP0[0][0]- mvQ0[0][0]);
				absMv[0][1] := abs(mvP0[0][1]- mvQ0[0][1]);
				if(not isBiPredTab[p0[0]][p0[1]] && (absMv[0][0]>=4 || absMv[0][1]>=4))then
					bS[0] := 1;
				else
					absMv[1][0] := abs(mvP0[1][0]- mvQ0[1][0]);
					absMv[1][1] := abs(mvP0[1][1]- mvQ0[1][1]);
					if(isBiPredTab[p0[0]][p0[1]] &&
					   refPocP0[0] != refPocP0[1] &&
					   (absMv[0][0]>=4 || absMv[0][1]>=4 || absMv[1][0]>=4 || absMv[1][1]>=4)) then
						bS[0] := 1;
					else
						if(isBiPredTab[p0[0]][p0[1]] &&
						   refPocP0[0] = refPocP0[1]) then
							absMvQP[0][0] := abs(mvP0[0][0]- mvQ0[1][0]);
							absMvQP[0][1] := abs(mvP0[0][1]- mvQ0[1][1]);
							absMvQP[1][0] := abs(mvP0[1][0]- mvQ0[0][0]);
							absMvQP[1][1] := abs(mvP0[1][1]- mvQ0[0][1]);
							if((absMv[0][0]>=4 || absMv[0][1]>=4 || absMv[1][0]>=4 || absMv[1][1]>=4) &&
							   (absMvQP[0][0]>=4 || absMvQP[0][1]>=4 || absMvQP[1][0]>=4
							   || absMvQP[1][1]>=4)) then
								bS[0] := 1;
							else
								bS[0] := 0;
							end
						else
							bS[0] := 0;
						end
					end
				end
			end
		end end end end
	end

	initialize ==>
	do
		bsTable := [[0: for int i in 0 .. 255]: for int j in 0 .. 1];
	end

	isNewSliceOrPict.isNotDep: action LcuSizeMax:[log2LcuSz], PartMode:[partMode],
		SliceAddr:[slcAddr] repeat 2, LFAcrossSlcTile:[lfAcrossSlcTile],
		TilesCoord:[valNumTiles] ==>
	guard
		partMode = PART_MODE_SLICE_INDEP || partMode = PART_MODE_PICT
	do
		lcuSizeMax := 1 << log2LcuSz;
		numTiles := valNumTiles;
		iLoop := 0;
		sliceAdr:= [slcAddr[0], slcAddr[1]];
		loopFilterAcrossSlc  := (lfAcrossSlcTile & 1) != 0;
		loopFilterAcrossTile := (lfAcrossSlcTile & 2) != 0;
	end

	isNewSliceOrPict.isDep: action PartMode:[partMode], SliceAddr:[slcAddr] repeat 2 ==>
	guard
		partMode = PART_MODE_SLICE_DEP
	do
		sliceAdr:= [slcAddr[0], slcAddr[1]];
	end

	getTilesCoord.launch: action TilesCoord:[tilesCoord] repeat 4 ==>
	guard
		iLoop < numTiles
	do
		tilesBeg[iLoop] := [tilesCoord[0], tilesCoord[1]];
		tilesEnd[iLoop] := [tilesCoord[2], tilesCoord[3]];
		iLoop := iLoop + 1;
	end

	getTilesCoord.done: action ==>
	guard
		iLoop = numTiles
	end

	/* Check when there are two parts in the CU.  */
	getPartMode.isNonQuadTree: action PartMode:[partMode] ==>
	guard
		partMode != PART_MODE_SLICE_DEP && partMode != PART_MODE_SLICE_INDEP &&
		partMode != PART_MODE_PICT,
		partMode != PART_2Nx2N && partMode != PART_NxN
	do
		currIdx := 0;
		numMvInfo := 2;
	end

	/* Check if all parts of the CU are a square. */
	getPartMode.isQuadTree: action PartMode:[partMode] ==>
	guard
		partMode = PART_2Nx2N || partMode = PART_NxN
	do
		numPart := partModeToNumPart[partMode];
		numPartDecoded := 0;
	end

	getRefPictInfo.launch.isNotBiPred: action IsBiPredOrLx:[isBiPredOrLx],
		RefPoc:[refPocVal], Mv:[mvVal] repeat 2 ==>
	guard
		isBiPredOrLx != BI_PRED and currIdx < numMvInfo
	do
		isBiPred[currIdx] := (isBiPredOrLx=BI_PRED);
		refPoc[currIdx][0] := refPocVal;
		if(currIdx=0) then
			mv[currIdx][0] := [mvVal[i]:for uint i in 0 .. 1];
		else
			mv[currIdx][0] := [mvVal[i]:for uint i in 0 .. 1];
		end
		currIdx := currIdx + 1;
	end

	getRefPictInfo.launch.isBiPred: action IsBiPredOrLx:[isBiPredOrLx],
		RefPoc:[refPocVal] repeat 2, Mv:[mvVal] repeat 4 ==>
	guard
		isBiPredOrLx = BI_PRED and currIdx < numMvInfo
	do
		isBiPred[currIdx] := (isBiPredOrLx=BI_PRED);
		refPoc[currIdx] := [refPocVal[i]:for uint i in 0 .. 1];
		if(currIdx=0) then
			mv[currIdx] := [[mvVal[i+2*j]:for uint i in 0 .. 1]: for uint j in 0 .. 1];
		else
			mv[currIdx] := [[mvVal[i+2*j]:for uint i in 0 .. 1]: for uint j in 0 .. 1];
		end
		currIdx := currIdx + 1;
	end

	getRefPictInfo.done: action ==>
	guard
		currIdx = numMvInfo
	do
		if(numMvInfo=1 or numMvInfo=0) then
			savePredInfo(cuAddr, [nS, nS], 0);
		end
	end

	/* Get the information concerning the CU to be able to save the values in
	 * currPict.
	 */
	getCuInfo.launch: action CUInfo:[cuInfo] repeat 5 ==>
	guard
		numPartDecoded < numPart
	do
		cuMode := cuInfo[0];
		nS := cuInfo[3];
		if((cuInfo[1]&~(lcuSizeMax - 1)) != (cuAddr[0]&~(lcuSizeMax - 1)) ||
		   (cuInfo[2]&~(lcuSizeMax - 1)) != (cuAddr[1]&~(lcuSizeMax - 1))) then
			findCurrTile(cuInfo[1], cuInfo[2]);
			rstEdgeTables([cuInfo[1], cuInfo[2]]);
		end
		cuAddr := [cuInfo[1], cuInfo[2]];
		coordMax1stPu[0] := (cuAddr[0] & (lcuSizeMax - 1)) + cuInfo[3] >>2;
		coordMax1stPu[1] := (cuAddr[1] & (lcuSizeMax - 1)) + cuInfo[4] >>2;
		numPartDecoded := numPartDecoded + 1;
	end

	/* When there are two parts, we get both part in once in order to perform a
	 * raster scan on the square (the SelectCU actor reorder the differents
	 * blocks)
	 */
	getCuInfo.nonQT: action CUInfo:[cuInfo] repeat 10 ==>
	var
		uint(size=8) puSize[2]
	do
		cuMode := cuInfo[0];
		if((cuInfo[1]&~(lcuSizeMax - 1)) != (cuAddr[0]&~(lcuSizeMax - 1)) ||
		   (cuInfo[2]&~(lcuSizeMax - 1)) != (cuAddr[1]&~(lcuSizeMax - 1))) then
			findCurrTile(cuInfo[1], cuInfo[2]);
			rstEdgeTables([cuInfo[1], cuInfo[2]]);
		end
		cuAddr := [cuInfo[1], cuInfo[2]];
		nS := max(cuInfo[3], cuInfo[4]);
		puSize := [cuInfo[3], cuInfo[4]];
		savePredInfo(cuAddr, puSize, 0);
		puSize := [cuInfo[8], cuInfo[9]];
		cuAddrNQT := [cuInfo[6], cuInfo[7]];
		savePredInfo(cuAddrNQT, puSize, 1);
		processPUBoundary(cuAddrNQT, puSize, cuInfo[2] != cuInfo[7]);
		numPart := 2;
		numPartDecoded := 2;
		trafoTreeDepth  := 0;
		trafoTreeIdx[0] := 3;

		coordMax1stPu[0] := (cuAddr[0] & (lcuSizeMax - 1)) + cuInfo[3] >>2;
		xMax1stPu        := cuAddr[0] + cuInfo[3];
		coordMax1stPu[1] := (cuAddr[1] & (lcuSizeMax - 1)) + cuInfo[4] >>2;
	end

	getCuInfo.done: action ==>
	guard
		numPartDecoded = numPart
	var
		int idxMax = nS * nS / 16
	do
		foreach int i in 0 .. idxMax - 1
		do
			bsTable[0][i] := 0;
			bsTable[1][i] := 0;
		end
	end

	getCuMode.isNotOther: action ==>
	guard
		cuMode = INTER || cuMode = SKIP || cuMode = INTRA
	do
		trafoTreeDepth  := 0;
		trafoTreeIdx[0] := 3;
		currIdx := 0;
		numMvInfo :=
			if(cuMode=INTRA) then
				0
			else
				1
			end;
	end

	/* When it's neither an intra nor inter prediction CU, do neither
	 * prediction nor saving pixels' value
	 */
	getCuMode.isOther: action ==>
	guard
		cuMode = OTHER
	end

	getSplitTrafo.launch.isTrue: action SplitTransf:[splitTrafo] ==>
	guard
		trafoTreeDepth>-1 && splitTrafo
	do
		trafoTreeDepth := trafoTreeDepth + 1;
		trafoTreeIdx[trafoTreeDepth] := 0;
	end

	getSplitTrafo.launch.isFalse: action SplitTransf:[splitTrafo], Cbf:[cbf] ==>
	guard
		trafoTreeDepth>-1 && not splitTrafo
	var
		uint(size=7)  treeNS,
		uint(size=16) treeAddr[2],
		uint(size=16) addrTU[2],
		uint(size=16) xMin,
		uint(size=16) xMax,
		uint(size=16) yMin,
		uint(size=16) yMax
	do

		/* Computing the size and the address of the current block. */
		treeNS := nS;
		treeAddr := [cuAddr[i]: for int i in 0 .. 1];
		foreach uint idx in 1 .. trafoTreeDepth
		do
			treeNS := treeNS >> 1;
			if((trafoTreeIdx[idx]&1) != 0) then
				treeAddr[0] := treeAddr[0] + treeNS;
			end
			if((trafoTreeIdx[idx]&2) != 0) then
				treeAddr[1] := treeAddr[1] + treeNS;
			end
		end

		xMin := (treeAddr[0] & (lcuSizeMax - 1))>>2;
		xMax := xMin+(treeNS>>2);
		yMin := (treeAddr[1] & (lcuSizeMax - 1))>>2;
		yMax := yMin + (treeNS>>2);
		processTUBoundaries(cbf, treeAddr, treeNS);

		/* Saving cbfNeighb, mvNeighb and refPocNeighb */
		foreach int x in treeAddr[0]>>2 .. (treeAddr[0] >> 2) + (treeNS>>2) - 1
		do
			cbfUpNeighb[x] := cbf;
			foreach int i in 0 .. 1
			do
				if(numMvInfo = 1 || x < (xMax1stPu>>2) && (yMax - 1) < coordMax1stPu[1]) then
					mvUpNeighb[x][i][0] := mv[0][i][0]-(cuAddr[0]<<2);
					mvUpNeighb[x][i][1] := mv[0][i][1]-(cuAddr[1]<<2);
					refPocUpNeighb[x][i] := refPoc[0][i];
				else
					mvUpNeighb[x][i][0] := mv[1][i][0]-(cuAddrNQT[0]<<2);
					mvUpNeighb[x][i][1] := mv[1][i][1]-(cuAddrNQT[1]<<2);
					refPocUpNeighb[x][i] := refPoc[1][i];
				end
			end
		end

		foreach int y in yMin .. yMax - 1
		do
			cbfLeftNeighb[(treeAddr[1]>>2) + y - yMin] := cbf;
			foreach int i in 0 .. 1
			do
				if((xMax-1) < coordMax1stPu[0] && y < coordMax1stPu[1]) then
					mvLeftNeighb[(treeAddr[1]>>2) + y - yMin][i][0] := mv[0][i][0]-(cuAddr[0]<<2);
					mvLeftNeighb[(treeAddr[1]>>2) + y - yMin][i][1] := mv[0][i][1]-(cuAddr[1]<<2);
					refPocLeftNeighb[(treeAddr[1]>>2) + y - yMin][i] := refPoc[0][i];
				else
					mvLeftNeighb[(treeAddr[1]>>2) + y - yMin][i][0] := mv[1][i][0]-(cuAddrNQT[0]<<2);
					mvLeftNeighb[(treeAddr[1]>>2) + y - yMin][i][1] := mv[1][i][1]-(cuAddrNQT[1]<<2);
					refPocLeftNeighb[(treeAddr[1]>>2) + y - yMin][i] := refPoc[1][i];
				end
			end
		end

		addrTU := [treeAddr[i] - cuAddr[i]: for int i in 0 .. 1];
		currIdx := absCoordToZScan(addrTU);
		nbBlkToSend := treeNS * treeNS / 16;

		trafoTreeIdx[trafoTreeDepth] := trafoTreeIdx[trafoTreeDepth] + 1;
		/* Replace by (trafoTreeDepth > -1 && trafoTreeIdx[trafoTreeDepth] = 4) when orcc's simulator
		 * support short-circuit evaluation.
		 */
		while(if trafoTreeDepth > -1 then trafoTreeIdx[trafoTreeDepth] = 4 else false end)
		do
			trafoTreeDepth := trafoTreeDepth - 1;
			if(trafoTreeDepth>-1) then
				trafoTreeIdx[trafoTreeDepth] :=
					trafoTreeIdx[trafoTreeDepth] + 1;
			end
		end
	end

	getSplitTrafo.done: action ==>
	guard
		trafoTreeDepth = -1
	do
		currIdx := absCoordToZScan(cuAddr);
	end

	sendBS.launch.is4x4: action ==> BS:[bs] repeat 2
	guard
		nbBlkToSend = 1
	var
		uint(size=2)  bs[2]
	do
		bs := [bsTable[i][currIdx]: for uint i in 0 .. 1];
		currIdx := currIdx + 1;
	end

	sendBS.launch.is8x8: action ==> BS:[bs] repeat 2 * 4
	guard
		nbBlkToSend = 4
	var
		uint(size=2)  bs[2 * 4]
	do
		foreach uint i in 0 .. 3
		do
			bs[i*2] := bsTable[0][currIdx+i];
			bs[i*2+1] := bsTable[1][currIdx+i];
		end
		currIdx := currIdx + 4;
	end

	sendBS.launch.is16x16: action ==> BS:[bs] repeat 2 * 16
	guard
		nbBlkToSend = 16
	var
		uint(size=2)  bs[2 * 16]
	do
		foreach uint i in 0 .. 15
		do
			bs[i*2] := bsTable[0][currIdx+i];
			bs[i*2+1] := bsTable[1][currIdx+i];
		end
		currIdx := currIdx + 16;
	end

	sendBS.launch.is32x32: action ==> BS:[bs] repeat 2 * 64
	guard
		nbBlkToSend = 64
	var
		uint(size=2)  bs[2 * 64]
	do
		foreach uint i in 0 .. 63
		do
			bs[i*2] := bsTable[0][currIdx+i];
			bs[i*2+1] := bsTable[1][currIdx+i];
		end
		currIdx := currIdx + 64;
	end

	sendBS.launch.is64x64: action ==> BS:[bs] repeat 2 * 256
	guard
		nbBlkToSend = 256
	var
		uint(size=2)  bs[2 * 256]
	do
		foreach uint i in 0 .. 255
		do
			bs[i*2] := bsTable[0][currIdx+i];
			bs[i*2+1] := bsTable[1][currIdx+i];
		end
		currIdx := currIdx + 256;
	end

	schedule fsm GetPartMode:
		GetPartMode(isNewSliceOrPict.isDep    )--> GetPartMode;
		GetPartMode(isNewSliceOrPict.isNotDep )--> GetTilesCoord;
		GetPartMode(getPartMode.isQuadTree    )--> GetCuInfo;
		GetPartMode(getPartMode.isNonQuadTree )--> GetRefPictInfo1;

		GetTilesCoord (getTilesCoord.launch )--> GetTilesCoord;
		GetTilesCoord (getTilesCoord.done   )--> GetPartMode;

		GetRefPictInfo1 (getRefPictInfo.launch )--> GetRefPictInfo1;
		GetRefPictInfo1 (getRefPictInfo.done   )--> GetCuInfoNonQT;
		GetCuInfoNonQT  (getCuInfo.nonQT       )--> GetSplitTrafo;

		GetCuInfo (getCuInfo.launch )--> GetCuMode;
		GetCuInfo (getCuInfo.done   )--> GetPartMode;

		GetCuMode (getCuMode.isNotOther )--> GetRefPictInfo;
		GetCuMode (getCuMode.isOther    )--> GetCuInfo;

		GetRefPictInfo (getRefPictInfo.launch )--> GetRefPictInfo;
		GetRefPictInfo (getRefPictInfo.done   )--> GetSplitTrafo;

		GetSplitTrafo (getSplitTrafo.launch.isTrue )--> GetSplitTrafo;
		GetSplitTrafo (getSplitTrafo.launch.isFalse )--> SendBS;
		GetSplitTrafo (getSplitTrafo.done   )--> GetCuInfo;

		SendBS (sendBS.launch )--> GetSplitTrafo;
	end
	priority
		sendBS.launch.is64x64 > sendBS.launch.is32x32 > sendBS.launch.is16x16 > sendBS.launch.is8x8 > sendBS.launch.is4x4;
	end
end
