/********************************************************************************

This software module was originally developed by 
Junaid Jameel Ahmad (EPFL), 
in the course of development of the ISO/IEC 23002-5 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-5.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-5 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards.

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-5 once the ISO/IEC 23002-5 has been adopted; and 
(2) to develop the ISO/IEC 23002-5: 

EPFL grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-5 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-5 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-5.  To the extent that EPFL
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-5 in a conforming product, EPFL
will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-5

EPFL retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2011-2015.
*****************************************************************************/

package org.sc29.wg11.mpegh.part2.main.synParser;

actor Two_Parsers_Merger ()
								// Parser 1 (p1)
                                uint(size=16) in1CUInfo, // Data port
                                uint(size= 6) in1IntraPredMode, // Data port
                                uint(size=16) in1SliceAddr, // Header port
                                uint(size=16) in1TilesCoord, // Header port
                                uint(size=16) in1RealTilesCoord, // Header port
                                uint(size= 8) in1LcuSizeMax, // Header port
                                uint(size= 4) in1PartMode, // Data port
               					uint(size= 2) in1IsPicSlcLcu, // Data port              					
               					uint(size= 2) in1IsPicSlc, // Header port
                				uint(size= 2) in1LFAcrossSlcTile, // Header port
                                uint(size=16) in1PictSize, // Header port
                                 int(size=16) in1Poc, // Header port
                                 int(size= 9) in1SaoSe, // Data port
                                uint(size= 8) in1SEI_MD5, // Header port
                                uint(size= 2) in1SliceType, // Header port
                                bool          in1SplitTransform, // Data port
                                 int(size= 8) in1TUSize, // Data port
                                 int(size=16) in1Coeff, // Data port
                                bool          in1StrongIntraSmoothing, // Header port
                                uint(size=14) in1DispCoord, // Header port
                                uint(size= 9) in1PicSizeInMb, // Header port
                                uint(size= 5) in1NumRefIdxLxActive, // Header port
                                uint(size= 4) in1RefPicListModif, // Header port
                                 int(size=16) in1RefPoc, // Header port
                                 int(size=16) in1MvPredSyntaxElem, // Data port                                
                                bool 		  in1Cbf, // Data port
                                bool		  in1DBFDisable, // Header port
                                 int(size= 8) in1DbfSe, // Header port
                                uint(size= 8) in1ReorderPics, // Header port
                                 int(size=16) in1WeightedPred, // Header port
                                uint(size=16) in1TileSize, // Header port
                                uint(size=16) in1TileCUInfo, // Data port
                                 int(size= 8) in1Qp, // Data port
                                 int(size= 8) in1HeaderControl,  // Control port
                                uint(size=16) in1NbTokens, // Control port                                  
                                
								// Parser 2 (p2)
                                uint(size=16) in2CUInfo, // Data port
                                uint(size= 6) in2IntraPredMode, // Data port
                                uint(size=16) in2SliceAddr, // Header port
                                uint(size=16) in2TilesCoord, // Header port
                                uint(size=16) in2RealTilesCoord, // Header port
                                uint(size= 8) in2LcuSizeMax, // Header port
                                uint(size= 4) in2PartMode, // Data port
               					uint(size= 2) in2IsPicSlcLcu, // Data port              					
               					uint(size= 2) in2IsPicSlc, // Header port
                				uint(size= 2) in2LFAcrossSlcTile, // Header port
                                uint(size=16) in2PictSize, // Header port
                                 int(size=16) in2Poc, // Header port
                                 int(size= 9) in2SaoSe, // Data port
                                uint(size= 8) in2SEI_MD5, // Header port
                                uint(size= 2) in2SliceType, // Header port
                                bool          in2SplitTransform, // Data port
                                 int(size= 8) in2TUSize, // Data port
                                 int(size=16) in2Coeff, // Data port
                                bool          in2StrongIntraSmoothing, // Header port
                                uint(size=14) in2DispCoord, // Header port
                                uint(size= 9) in2PicSizeInMb, // Header port
                                uint(size= 5) in2NumRefIdxLxActive, // Header port
                                uint(size= 4) in2RefPicListModif, // Header port
                                 int(size=16) in2RefPoc, // Header port
                                 int(size=16) in2MvPredSyntaxElem, // Data port                                
                                bool 		  in2Cbf, // Data port
                                bool		  in2DBFDisable, // Header port
                                 int(size= 8) in2DbfSe, // Header port
                                uint(size= 8) in2ReorderPics, // Header port
                                 int(size=16) in2WeightedPred, // Header port
                                uint(size=16) in2TileSize, // Header port
                                uint(size=16) in2TileCUInfo, // Data port
                                 int(size= 8) in2Qp, // Data port
                                 int(size= 8) in2HeaderControl,  // Control port
                                uint(size=16) in2NbTokens // Control port
                                  
                                ==>
                                // Output ports
                                uint(size=16) opCUInfo,
                                uint(size= 6) opIntraPredMode,
                                uint(size=16) opSliceAddr,
                                uint(size=16) opTilesCoord,
                                uint(size=16) opRealTilesCoord,
                                uint(size= 8) opLcuSizeMax,
                                uint(size= 4) opPartMode,
               					uint(size= 2) opIsPicSlcLcu,
               					uint(size= 2) opIsPicSlc,
                				uint(size= 2) opLFAcrossSlcTile,
                                uint(size=16) opPictSize,
                                 int(size=16) opPoc,
                                 int(size= 9) opSaoSe,
                                uint(size= 8) opSEI_MD5,
                                uint(size= 2) opSliceType,
                                bool          opSplitTransform,
                                 int(size= 8) opTUSize,
                                 int(size=16) opCoeff,
                                bool          opStrongIntraSmoothing,
                                uint(size=14) opDispCoord,
                                uint(size= 9)  opPicSizeInMb,
                                uint(size= 5) opNumRefIdxLxActive,
                                uint(size= 4) opRefPicListModif,
                                 int(size=16) opRefPoc,
                                 int(size=16) opMvPredSyntaxElem,
                                bool		  opCbf,
                                bool		  opDBFDisable,
                                 int(size= 8) opDbfSe,
                                uint(size= 8) opReorderPics,
                                 int(size=16) opWeightedPred,
                                uint(size=16) opTileSize,
                                uint(size=16) opTileCUInfo,
                                 int(size= 8) opQp
:

/*--------------------- p1.Header_Fwd ---------------------*/
	p1.Header_Fwd_Done_SliceAdd:
	action in1SliceAddr:[x] repeat 2 ==> opSliceAddr:[x] repeat 2
	guard cntTokensPerSH[0] < nbTokensPerSH[0]
	do
		cntTokensPerSH[0] := cntTokensPerSH[0] + 2;
ifTokenDiffsSH();
	end
	
	p1.Header_Fwd.TilesCoord:
	action in1TilesCoord:[x] ==> opTilesCoord:[x]
	guard cntTokensPerSH[1] < nbTokensPerSH[1]
	do
		cntTokensPerSH[1] := cntTokensPerSH[1] + 1;
	end
	
	p1.Header_Fwd.RealTilesCoord:
	action in1RealTilesCoord:[x] ==> opRealTilesCoord:[x]	
	guard cntTokensPerSH[2] < nbTokensPerSH[2]
	do
		cntTokensPerSH[2] := cntTokensPerSH[2] + 1;
	end
	
	p1.Header_Fwd.LcuSizeMax:
	action in1LcuSizeMax:[x] ==> opLcuSizeMax:[x]
	guard cntTokensPerSH[3] < nbTokensPerSH[3]
	do
		cntTokensPerSH[3] := cntTokensPerSH[3] + 1;
	end

	p1.Header_Fwd.PartModeSH:
	action in1PartMode:[x] ==> opPartMode:[x] 
	guard cntTokensPerSH[4] < nbTokensPerSH[4]
	do
		cntTokensPerSH[4] := cntTokensPerSH[4] + 1;
	end

	p1.Header_Fwd.IsPicSlcLcuSH:
	action in1IsPicSlcLcu:[x] ==> opIsPicSlcLcu:[x]
	guard cntTokensPerSH[5] < nbTokensPerSH[5]
	do
		cntTokensPerSH[5] := cntTokensPerSH[5] + 1;
	end
	
	p1.Header_Fwd.IsPicSlc:
	action in1IsPicSlc:[x] ==> opIsPicSlc:[x]
	guard cntTokensPerSH[6] < nbTokensPerSH[6]
	do
		cntTokensPerSH[6] := cntTokensPerSH[6] + 1;
	end
	
	p1.Header_Fwd.LFAcrossSlcTile:
	action in1LFAcrossSlcTile:[x] ==> opLFAcrossSlcTile:[x]	
	guard cntTokensPerSH[7] < nbTokensPerSH[7]
	do
		cntTokensPerSH[7] := cntTokensPerSH[7] + 1;
	end
	
	p1.Header_Fwd.PictSize:
	action in1PictSize:[x] repeat 2 ==> opPictSize:[x] repeat 2
	guard cntTokensPerSH[8] < nbTokensPerSH[8]
	do
		cntTokensPerSH[8] := cntTokensPerSH[8] + 2;
	end

	p1.Header_Fwd.Poc:
	action in1Poc:[x] ==> opPoc:[x]
	guard cntTokensPerSH[9] < nbTokensPerSH[9]
	do
		cntTokensPerSH[9] := cntTokensPerSH[9] + 1;
	end
	
	p1.Header_Fwd.SaoSeSH:
	action in1SaoSe:[x] ==> opSaoSe:[x]
	guard cntTokensPerSH[10] < nbTokensPerSH[10]
	do
		cntTokensPerSH[10] := cntTokensPerSH[10] + 1;
	end
	
	p1.Header_Fwd.SEI_MD5:
	action in1SEI_MD5:[x] ==> opSEI_MD5:[x]
	guard cntTokensPerSH[11] < nbTokensPerSH[11]
	do
		cntTokensPerSH[11] := cntTokensPerSH[11] + 1;
	end

	p1.Header_Fwd.SliceType:
	action in1SliceType:[x] ==> opSliceType:[x]
	guard cntTokensPerSH[12] < nbTokensPerSH[12]
	do
		cntTokensPerSH[12] := cntTokensPerSH[12] + 1;
	end
	
	p1.Header_Fwd.StrongIntraSmoothing:
	action in1StrongIntraSmoothing:[x] repeat 2 ==> opStrongIntraSmoothing:[x] repeat 2
	guard cntTokensPerSH[13] < nbTokensPerSH[13]
	do
		cntTokensPerSH[13] := cntTokensPerSH[13] + 2;
	end
	
	p1.Header_Fwd.DispCoord:
	action in1DispCoord:[x] repeat 4 ==> opDispCoord:[x] repeat 4
	guard cntTokensPerSH[14] < nbTokensPerSH[14]
	do
		cntTokensPerSH[14] := cntTokensPerSH[14] + 4;
	end
	
	p1.Header_Fwd.PicSizeInMb:
	action in1PicSizeInMb:[x] repeat 2 ==> opPicSizeInMb:[x] repeat 2
	guard cntTokensPerSH[15] < nbTokensPerSH[15]
	do
		cntTokensPerSH[15] := cntTokensPerSH[15] + 2;
	end
	
	p1.Header_Fwd.NumRefIdxLxActive:
	action in1NumRefIdxLxActive:[x] repeat 2 ==> opNumRefIdxLxActive:[x] repeat 2
	guard cntTokensPerSH[16] < nbTokensPerSH[16]
	do
		cntTokensPerSH[16] := cntTokensPerSH[16] + 2;
	end

	p1.Header_Fwd.RefPicListModif:
	action in1RefPicListModif:[x] ==> opRefPicListModif:[x]
	guard cntTokensPerSH[17] < nbTokensPerSH[17]
	do
		cntTokensPerSH[17] := cntTokensPerSH[17] + 1;
	end
	
	p1.Header_Fwd.RefPoc:
	action in1RefPoc:[x] ==> opRefPoc:[x]
	guard cntTokensPerSH[18] < nbTokensPerSH[18]
	do
		cntTokensPerSH[18] := cntTokensPerSH[18] + 1;
	end

	p1.Header_Fwd.MvPredSyntaxElemSH:
	action in1MvPredSyntaxElem:[x] repeat 2 ==> opMvPredSyntaxElem:[x] repeat 2
	guard cntTokensPerSH[19] < nbTokensPerSH[19]
	do
		cntTokensPerSH[19] := cntTokensPerSH[19] + 2;
	end
	
	p1.Header_Fwd.DBFDisable:
	action in1DBFDisable:[x] ==> opDBFDisable:[x]
	guard cntTokensPerSH[20] < nbTokensPerSH[20]
	do
		cntTokensPerSH[20] := cntTokensPerSH[20] + 1;
	end

	p1.Header_Fwd.DbfSe:
	action in1DbfSe:[x] repeat 4 ==> opDbfSe:[x] repeat 4
	guard cntTokensPerSH[21] < nbTokensPerSH[21]
	do
		cntTokensPerSH[21] := cntTokensPerSH[21] + 4;
	end
	
	p1.Header_Fwd.ReorderPics:
	action in1ReorderPics:[x] repeat 7 ==> opReorderPics:[x] repeat 7
	guard cntTokensPerSH[22] < nbTokensPerSH[22]
	do
		cntTokensPerSH[22] := cntTokensPerSH[22] + 7;
	end
	
	p1.Header_Fwd.WeightedPred:
	action in1WeightedPred:[x] ==> opWeightedPred:[x]
	guard cntTokensPerSH[23] < nbTokensPerSH[23]
	do
		cntTokensPerSH[23] := cntTokensPerSH[23] + 1;
	end
	
	p1.Header_Fwd.TileSize:
	action in1TileSize:[x] repeat 2 ==> opTileSize:[x] repeat 2		
	guard cntTokensPerSH[24] < nbTokensPerSH[24]
	do
		cntTokensPerSH[24] := cntTokensPerSH[24] + 2;
	end

/*--------------------- p1.Header_Eat ---------------------*/
	p1.Header_Eat_Done_SliceAdd:
	action in1SliceAddr:[x] repeat 2 ==> 
	guard cntTokensPerSH[0] < nbTokensPerSH[0]
	do
		cntTokensPerSH[0] := cntTokensPerSH[0] + 2;
//println("p1.Header_Eat_Done_SliceAdd");		
ifTokenDiffsSH();		
	end
	
	p1.Header_Eat.TilesCoord:
	action in1TilesCoord:[x] ==> 
	guard cntTokensPerSH[1] < nbTokensPerSH[1]
	do
		cntTokensPerSH[1] := cntTokensPerSH[1] + 1;
	end
	
	p1.Header_Eat.RealTilesCoord:
	action in1RealTilesCoord:[x] ==> 
	guard cntTokensPerSH[2] < nbTokensPerSH[2]
	do
		cntTokensPerSH[2] := cntTokensPerSH[2] + 1;
	end
	
	p1.Header_Eat.LcuSizeMax:
	action in1LcuSizeMax:[x] ==> 
	guard cntTokensPerSH[3] < nbTokensPerSH[3]
	do
		cntTokensPerSH[3] := cntTokensPerSH[3] + 1;
	end

	p1.Header_Eat.PartModeSH:
	action in1PartMode:[x] ==> 
	guard cntTokensPerSH[4] < nbTokensPerSH[4]
	do
		cntTokensPerSH[4] := cntTokensPerSH[4] + 1;
	end

	p1.Header_Eat.IsPicSlcLcuSH:
	action in1IsPicSlcLcu:[x] ==> 
	guard cntTokensPerSH[5] < nbTokensPerSH[5]
	do
		cntTokensPerSH[5] := cntTokensPerSH[5] + 1;
	end
	
	p1.Header_Eat.IsPicSlc:
	action in1IsPicSlc:[x] ==> 
	guard cntTokensPerSH[6] < nbTokensPerSH[6]
	do
		cntTokensPerSH[6] := cntTokensPerSH[6] + 1;
	end
	
	p1.Header_Eat.LFAcrossSlcTile:
	action in1LFAcrossSlcTile:[x] ==> 
	guard cntTokensPerSH[7] < nbTokensPerSH[7]
	do
		cntTokensPerSH[7] := cntTokensPerSH[7] + 1;
	end
	
	p1.Header_Eat.PictSize:
	action in1PictSize:[x] repeat 2 ==> 
	guard cntTokensPerSH[8] < nbTokensPerSH[8]
	do
		cntTokensPerSH[8] := cntTokensPerSH[8] + 2;
	end

	p1.Header_Eat.Poc:
	action in1Poc:[x] ==> 
	guard cntTokensPerSH[9] < nbTokensPerSH[9]
	do
		cntTokensPerSH[9] := cntTokensPerSH[9] + 1;
	end
	
	p1.Header_Eat.SaoSeSH:
	action in1SaoSe:[x] ==> 
	guard cntTokensPerSH[10] < nbTokensPerSH[10]
	do
		cntTokensPerSH[10] := cntTokensPerSH[10] + 1;
	end
	
	p1.Header_Eat.SEI_MD5:
	action in1SEI_MD5:[x] ==> 
	guard cntTokensPerSH[11] < nbTokensPerSH[11]
	do
		cntTokensPerSH[11] := cntTokensPerSH[11] + 1;
	end

	p1.Header_Eat.SliceType:
	action in1SliceType:[x] ==> 
	guard cntTokensPerSH[12] < nbTokensPerSH[12]
	do
		cntTokensPerSH[12] := cntTokensPerSH[12] + 1;
	end
	
	p1.Header_Eat.StrongIntraSmoothing:
	action in1StrongIntraSmoothing:[x] repeat 2 ==> 
	guard cntTokensPerSH[13] < nbTokensPerSH[13]
	do
		cntTokensPerSH[13] := cntTokensPerSH[13] + 2;
	end
	
	p1.Header_Eat.DispCoord:
	action in1DispCoord:[x] repeat 4 ==> 
	guard cntTokensPerSH[14] < nbTokensPerSH[14]
	do
		cntTokensPerSH[14] := cntTokensPerSH[14] + 4;
	end
	
	p1.Header_Eat.PicSizeInMb:
	action in1PicSizeInMb:[x] repeat 2 ==> 
	guard cntTokensPerSH[15] < nbTokensPerSH[15]
	do
		cntTokensPerSH[15] := cntTokensPerSH[15] + 2;
	end
	
	p1.Header_Eat.NumRefIdxLxActive:
	action in1NumRefIdxLxActive:[x] repeat 2 ==> 
	guard cntTokensPerSH[16] < nbTokensPerSH[16]
	do
		cntTokensPerSH[16] := cntTokensPerSH[16] + 2;
	end

	p1.Header_Eat.RefPicListModif:
	action in1RefPicListModif:[x] ==> 
	guard cntTokensPerSH[17] < nbTokensPerSH[17]
	do
		cntTokensPerSH[17] := cntTokensPerSH[17] + 1;
	end
	
	p1.Header_Eat.RefPoc:
	action in1RefPoc:[x] ==> 
	guard cntTokensPerSH[18] < nbTokensPerSH[18]
	do
		cntTokensPerSH[18] := cntTokensPerSH[18] + 1;
	end

	p1.Header_Eat.MvPredSyntaxElemSH:
	action in1MvPredSyntaxElem:[x] repeat 2 ==> 
	guard cntTokensPerSH[19] < nbTokensPerSH[19]
	do
		cntTokensPerSH[19] := cntTokensPerSH[19] + 2;
	end
	
	p1.Header_Eat.DBFDisable:
	action in1DBFDisable:[x] ==> 
	guard cntTokensPerSH[20] < nbTokensPerSH[20]
	do
		cntTokensPerSH[20] := cntTokensPerSH[20] + 1;
	end

	p1.Header_Eat.DbfSe:
	action in1DbfSe:[x] repeat 4 ==> 
	guard cntTokensPerSH[21] < nbTokensPerSH[21]
	do
		cntTokensPerSH[21] := cntTokensPerSH[21] + 4;
	end
	
	p1.Header_Eat.ReorderPics:
	action in1ReorderPics:[x] repeat 7 ==> 
	guard cntTokensPerSH[22] < nbTokensPerSH[22]
	do
		cntTokensPerSH[22] := cntTokensPerSH[22] + 7;
	end
	
	p1.Header_Eat.WeightedPred:
	action in1WeightedPred:[x] ==> 
	guard cntTokensPerSH[23] < nbTokensPerSH[23]
	do
		cntTokensPerSH[23] := cntTokensPerSH[23] + 1;
	end
	
	p1.Header_Eat.TileSize:
	action in1TileSize:[x] repeat 2 ==> 
	guard cntTokensPerSH[24] < nbTokensPerSH[24]
	do
		cntTokensPerSH[24] := cntTokensPerSH[24] + 2;
	end

/*--------------------- p1.Data ---------------------*/	
	p1.Data.CUInfo:
	action in1CUInfo:[x] repeat 5 ==> opCUInfo:[x] repeat 5
	guard cntTokensPerCTU[0] < nbTokensPerCTU[0] 
	do
		cntTokensPerCTU[0] := cntTokensPerCTU[0] + 5;
	end

	p1.Data.IntraPredMode:
	action in1IntraPredMode:[x] repeat 2 ==> opIntraPredMode:[x] repeat 2 
	guard cntTokensPerCTU[1] < nbTokensPerCTU[1] 
	do
		cntTokensPerCTU[1] := cntTokensPerCTU[1] + 2;
	end
	
	p1.Data.PartMode:
	action in1PartMode:[x] ==> opPartMode:[x]
	guard cntTokensPerCTU[2] < nbTokensPerCTU[2] 
	do
		cntTokensPerCTU[2] := cntTokensPerCTU[2] + 1;
	end
	
	p1.Data.IsPicSlcLcu:
	action in1IsPicSlcLcu:[x] ==> opIsPicSlcLcu:[x]
	guard cntTokensPerCTU[3] < nbTokensPerCTU[3] 
	do
		cntTokensPerCTU[3] := cntTokensPerCTU[3] + 1;
	end

	p1.Data.SaoSe:
	action in1SaoSe:[x] ==> opSaoSe:[x]
	guard cntTokensPerCTU[4] < nbTokensPerCTU[4] 
	do
		cntTokensPerCTU[4] := cntTokensPerCTU[4] + 1;
	end

	p1.Data.SplitTransform:
	action in1SplitTransform:[x] ==> opSplitTransform:[x]	
	guard cntTokensPerCTU[5] < nbTokensPerCTU[5] 
	do
		cntTokensPerCTU[5] := cntTokensPerCTU[5] + 1;
	end
	
	p1.Data.TUSize:
	action in1TUSize:[x] repeat 7 ==> opTUSize:[x] repeat 7
	guard cntTokensPerCTU[6] < nbTokensPerCTU[6] 
	do
		cntTokensPerCTU[6] := cntTokensPerCTU[6] + 7;
	end

	p1.Data.Coeff:
	action in1Coeff:[x] repeat 16 ==> opCoeff:[x] repeat 16		
	guard cntTokensPerCTU[7] < nbTokensPerCTU[7] 
	do
		cntTokensPerCTU[7] := cntTokensPerCTU[7] + 16;
	end
	
	p1.Data.MvPredSyntaxElem:
	action in1MvPredSyntaxElem:[x] ==> opMvPredSyntaxElem:[x]
	guard cntTokensPerCTU[8] < nbTokensPerCTU[8] 
	do
		cntTokensPerCTU[8] := cntTokensPerCTU[8] + 1;
	end
	
	p1.Data.Cbf:
	action in1Cbf:[x] ==> opCbf:[x]
	guard cntTokensPerCTU[9] < nbTokensPerCTU[9] 
	do
		cntTokensPerCTU[9] := cntTokensPerCTU[9] + 1;
	end
	
	p1.Data.TileCUInfo:
	action in1TileCUInfo:[x] repeat 5 ==> opTileCUInfo:[x] repeat 5	
	guard cntTokensPerCTU[10] < nbTokensPerCTU[10] 
	do
		cntTokensPerCTU[10] := cntTokensPerCTU[10] + 5;
	end
	
	p1.Data.Qp:
	action in1Qp:[x] repeat 2 ==> opQp:[x] repeat 2	
	guard cntTokensPerCTU[11] < nbTokensPerCTU[11] 
	do
		cntTokensPerCTU[11] := cntTokensPerCTU[11] + 2;
	end
	
	p1.Data_endCTU:
	action ==>
	do
		cntCTUs := cntCTUs + 1;	
//println("p1.Data_ctuFinished");
ifTokenDiffsCTU();
	end	
	
/*--------------------- p2.Header_Fwd ---------------------*/
	p2.Header_Fwd_Done_SliceAdd:
	action in2SliceAddr:[x] repeat 2 ==> opSliceAddr:[x] repeat 2
	guard cntTokensPerSH[0] < nbTokensPerSH[0]
	do
		cntTokensPerSH[0] := cntTokensPerSH[0] + 2;
ifTokenDiffsSH();		
	end
	
	p2.Header_Fwd.TilesCoord:
	action in2TilesCoord:[x] ==> opTilesCoord:[x]
	guard cntTokensPerSH[1] < nbTokensPerSH[1]
	do
		cntTokensPerSH[1] := cntTokensPerSH[1] + 1;
	end
	
	p2.Header_Fwd.RealTilesCoord:
	action in2RealTilesCoord:[x] ==> opRealTilesCoord:[x]	
	guard cntTokensPerSH[2] < nbTokensPerSH[2]
	do
		cntTokensPerSH[2] := cntTokensPerSH[2] + 1;
	end
	
	p2.Header_Fwd.LcuSizeMax:
	action in2LcuSizeMax:[x] ==> opLcuSizeMax:[x]
	guard cntTokensPerSH[3] < nbTokensPerSH[3]
	do
		cntTokensPerSH[3] := cntTokensPerSH[3] + 1;
	end

	p2.Header_Fwd.PartModeSH:
	action in2PartMode:[x] ==> opPartMode:[x] 
	guard cntTokensPerSH[4] < nbTokensPerSH[4]
	do
		cntTokensPerSH[4] := cntTokensPerSH[4] + 1;
	end

	p2.Header_Fwd.IsPicSlcLcuSH:
	action in2IsPicSlcLcu:[x] ==> opIsPicSlcLcu:[x]
	guard cntTokensPerSH[5] < nbTokensPerSH[5]
	do
		cntTokensPerSH[5] := cntTokensPerSH[5] + 1;
	end
	
	p2.Header_Fwd.IsPicSlc:
	action in2IsPicSlc:[x] ==> opIsPicSlc:[x]
	guard cntTokensPerSH[6] < nbTokensPerSH[6]
	do
		cntTokensPerSH[6] := cntTokensPerSH[6] + 1;
	end
	
	p2.Header_Fwd.LFAcrossSlcTile:
	action in2LFAcrossSlcTile:[x] ==> opLFAcrossSlcTile:[x]	
	guard cntTokensPerSH[7] < nbTokensPerSH[7]
	do
		cntTokensPerSH[7] := cntTokensPerSH[7] + 1;
	end
	
	p2.Header_Fwd.PictSize:
	action in2PictSize:[x] repeat 2 ==> opPictSize:[x] repeat 2
	guard cntTokensPerSH[8] < nbTokensPerSH[8]
	do
		cntTokensPerSH[8] := cntTokensPerSH[8] + 2;
	end

	p2.Header_Fwd.Poc:
	action in2Poc:[x] ==> opPoc:[x]
	guard cntTokensPerSH[9] < nbTokensPerSH[9]
	do
		cntTokensPerSH[9] := cntTokensPerSH[9] + 1;
	end
	
	p2.Header_Fwd.SaoSeSH:
	action in2SaoSe:[x] ==> opSaoSe:[x]
	guard cntTokensPerSH[10] < nbTokensPerSH[10]
	do
		cntTokensPerSH[10] := cntTokensPerSH[10] + 1;
	end
	
	p2.Header_Fwd.SEI_MD5:
	action in2SEI_MD5:[x] ==> opSEI_MD5:[x]
	guard cntTokensPerSH[11] < nbTokensPerSH[11]
	do
		cntTokensPerSH[11] := cntTokensPerSH[11] + 1;
	end

	p2.Header_Fwd.SliceType:
	action in2SliceType:[x] ==> opSliceType:[x]
	guard cntTokensPerSH[12] < nbTokensPerSH[12]
	do
		cntTokensPerSH[12] := cntTokensPerSH[12] + 1;
	end
	
	p2.Header_Fwd.StrongIntraSmoothing:
	action in2StrongIntraSmoothing:[x] repeat 2 ==> opStrongIntraSmoothing:[x] repeat 2
	guard cntTokensPerSH[13] < nbTokensPerSH[13]
	do
		cntTokensPerSH[13] := cntTokensPerSH[13] + 2;
	end
	
	p2.Header_Fwd.DispCoord:
	action in2DispCoord:[x] repeat 4 ==> opDispCoord:[x] repeat 4
	guard cntTokensPerSH[14] < nbTokensPerSH[14]
	do
		cntTokensPerSH[14] := cntTokensPerSH[14] + 4;
	end
	
	p2.Header_Fwd.PicSizeInMb:
	action in2PicSizeInMb:[x] repeat 2 ==> opPicSizeInMb:[x] repeat 2
	guard cntTokensPerSH[15] < nbTokensPerSH[15]
	do
		cntTokensPerSH[15] := cntTokensPerSH[15] + 2;
	end
	
	p2.Header_Fwd.NumRefIdxLxActive:
	action in2NumRefIdxLxActive:[x] repeat 2 ==> opNumRefIdxLxActive:[x] repeat 2
	guard cntTokensPerSH[16] < nbTokensPerSH[16]
	do
		cntTokensPerSH[16] := cntTokensPerSH[16] + 2;
	end

	p2.Header_Fwd.RefPicListModif:
	action in2RefPicListModif:[x] ==> opRefPicListModif:[x]
	guard cntTokensPerSH[17] < nbTokensPerSH[17]
	do
		cntTokensPerSH[17] := cntTokensPerSH[17] + 1;
	end
	
	p2.Header_Fwd.RefPoc:
	action in2RefPoc:[x] ==> opRefPoc:[x]
	guard cntTokensPerSH[18] < nbTokensPerSH[18]
	do
		cntTokensPerSH[18] := cntTokensPerSH[18] + 1;
	end

	p2.Header_Fwd.MvPredSyntaxElemSH:
	action in2MvPredSyntaxElem:[x] repeat 2 ==> opMvPredSyntaxElem:[x] repeat 2
	guard cntTokensPerSH[19] < nbTokensPerSH[19]
	do
		cntTokensPerSH[19] := cntTokensPerSH[19] + 2;
	end
	
	p2.Header_Fwd.DBFDisable:
	action in2DBFDisable:[x] ==> opDBFDisable:[x]
	guard cntTokensPerSH[20] < nbTokensPerSH[20]
	do
		cntTokensPerSH[20] := cntTokensPerSH[20] + 1;
	end

	p2.Header_Fwd.DbfSe:
	action in2DbfSe:[x] repeat 4 ==> opDbfSe:[x] repeat 4
	guard cntTokensPerSH[21] < nbTokensPerSH[21]
	do
		cntTokensPerSH[21] := cntTokensPerSH[21] + 4;
	end
	
	p2.Header_Fwd.ReorderPics:
	action in2ReorderPics:[x] repeat 7 ==> opReorderPics:[x] repeat 7
	guard cntTokensPerSH[22] < nbTokensPerSH[22]
	do
		cntTokensPerSH[22] := cntTokensPerSH[22] + 7;
	end
	
	p2.Header_Fwd.WeightedPred:
	action in2WeightedPred:[x] ==> opWeightedPred:[x]
	guard cntTokensPerSH[23] < nbTokensPerSH[23]
	do
		cntTokensPerSH[23] := cntTokensPerSH[23] + 1;
	end
	
	p2.Header_Fwd.TileSize:
	action in2TileSize:[x] repeat 2 ==> opTileSize:[x] repeat 2		
	guard cntTokensPerSH[24] < nbTokensPerSH[24]
	do
		cntTokensPerSH[24] := cntTokensPerSH[24] + 2;
	end
/*--------------------- p2.Header_Eat ---------------------*/
	p2.Header_Eat_Done_SliceAdd:
	action in2SliceAddr:[x] repeat 2 ==> 
	guard cntTokensPerSH[0] < nbTokensPerSH[0]
	do
		cntTokensPerSH[0] := cntTokensPerSH[0] + 2;
//println("p2.Header_Eat_Done_SliceAdd");		
ifTokenDiffsSH();
	end
	
	p2.Header_Eat.TilesCoord:
	action in2TilesCoord:[x] ==> 
	guard cntTokensPerSH[1] < nbTokensPerSH[1]
	do
		cntTokensPerSH[1] := cntTokensPerSH[1] + 1;
	end
	
	p2.Header_Eat.RealTilesCoord:
	action in2RealTilesCoord:[x] ==> 
	guard cntTokensPerSH[2] < nbTokensPerSH[2]
	do
		cntTokensPerSH[2] := cntTokensPerSH[2] + 1;
	end
	
	p2.Header_Eat.LcuSizeMax:
	action in2LcuSizeMax:[x] ==> 
	guard cntTokensPerSH[3] < nbTokensPerSH[3]
	do
		cntTokensPerSH[3] := cntTokensPerSH[3] + 1;
	end

	p2.Header_Eat.PartModeSH:
	action in2PartMode:[x] ==> 
	guard cntTokensPerSH[4] < nbTokensPerSH[4]
	do
		cntTokensPerSH[4] := cntTokensPerSH[4] + 1;
	end

	p2.Header_Eat.IsPicSlcLcuSH:
	action in2IsPicSlcLcu:[x] ==> 
	guard cntTokensPerSH[5] < nbTokensPerSH[5]
	do
		cntTokensPerSH[5] := cntTokensPerSH[5] + 1;
	end
	
	p2.Header_Eat.IsPicSlc:
	action in2IsPicSlc:[x] ==> 
	guard cntTokensPerSH[6] < nbTokensPerSH[6]
	do
		cntTokensPerSH[6] := cntTokensPerSH[6] + 1;
	end
	
	p2.Header_Eat.LFAcrossSlcTile:
	action in2LFAcrossSlcTile:[x] ==> 
	guard cntTokensPerSH[7] < nbTokensPerSH[7]
	do
		cntTokensPerSH[7] := cntTokensPerSH[7] + 1;
	end
	
	p2.Header_Eat.PictSize:
	action in2PictSize:[x] repeat 2 ==> 
	guard cntTokensPerSH[8] < nbTokensPerSH[8]
	do
		cntTokensPerSH[8] := cntTokensPerSH[8] + 2;
	end

	p2.Header_Eat.Poc:
	action in2Poc:[x] ==> 
	guard cntTokensPerSH[9] < nbTokensPerSH[9]
	do
		cntTokensPerSH[9] := cntTokensPerSH[9] + 1;
	end
	
	p2.Header_Eat.SaoSeSH:
	action in2SaoSe:[x] ==> 
	guard cntTokensPerSH[10] < nbTokensPerSH[10]
	do
		cntTokensPerSH[10] := cntTokensPerSH[10] + 1;
	end
	
	p2.Header_Eat.SEI_MD5:
	action in2SEI_MD5:[x] ==> 
	guard cntTokensPerSH[11] < nbTokensPerSH[11]
	do
		cntTokensPerSH[11] := cntTokensPerSH[11] + 1;
	end

	p2.Header_Eat.SliceType:
	action in2SliceType:[x] ==> 
	guard cntTokensPerSH[12] < nbTokensPerSH[12]
	do
		cntTokensPerSH[12] := cntTokensPerSH[12] + 1;
	end
	
	p2.Header_Eat.StrongIntraSmoothing:
	action in2StrongIntraSmoothing:[x] repeat 2 ==> 
	guard cntTokensPerSH[13] < nbTokensPerSH[13]
	do
		cntTokensPerSH[13] := cntTokensPerSH[13] + 2;
	end
	
	p2.Header_Eat.DispCoord:
	action in2DispCoord:[x] repeat 4 ==> 
	guard cntTokensPerSH[14] < nbTokensPerSH[14]
	do
		cntTokensPerSH[14] := cntTokensPerSH[14] + 4;
	end
	
	p2.Header_Eat.PicSizeInMb:
	action in2PicSizeInMb:[x] repeat 2 ==> 
	guard cntTokensPerSH[15] < nbTokensPerSH[15]
	do
		cntTokensPerSH[15] := cntTokensPerSH[15] + 2;
	end
	
	p2.Header_Eat.NumRefIdxLxActive:
	action in2NumRefIdxLxActive:[x] repeat 2 ==> 
	guard cntTokensPerSH[16] < nbTokensPerSH[16]
	do
		cntTokensPerSH[16] := cntTokensPerSH[16] + 2;
	end

	p2.Header_Eat.RefPicListModif:
	action in2RefPicListModif:[x] ==> 
	guard cntTokensPerSH[17] < nbTokensPerSH[17]
	do
		cntTokensPerSH[17] := cntTokensPerSH[17] + 1;
	end
	
	p2.Header_Eat.RefPoc:
	action in2RefPoc:[x] ==> 
	guard cntTokensPerSH[18] < nbTokensPerSH[18]
	do
		cntTokensPerSH[18] := cntTokensPerSH[18] + 1;
	end

	p2.Header_Eat.MvPredSyntaxElemSH:
	action in2MvPredSyntaxElem:[x] repeat 2 ==> 
	guard cntTokensPerSH[19] < nbTokensPerSH[19]
	do
		cntTokensPerSH[19] := cntTokensPerSH[19] + 2;
	end
	
	p2.Header_Eat.DBFDisable:
	action in2DBFDisable:[x] ==> 
	guard cntTokensPerSH[20] < nbTokensPerSH[20]
	do
		cntTokensPerSH[20] := cntTokensPerSH[20] + 1;
	end

	p2.Header_Eat.DbfSe:
	action in2DbfSe:[x] repeat 4 ==> 
	guard cntTokensPerSH[21] < nbTokensPerSH[21]
	do
		cntTokensPerSH[21] := cntTokensPerSH[21] + 4;
	end
	
	p2.Header_Eat.ReorderPics:
	action in2ReorderPics:[x] repeat 7 ==> 
	guard cntTokensPerSH[22] < nbTokensPerSH[22]
	do
		cntTokensPerSH[22] := cntTokensPerSH[22] + 7;
	end
	
	p2.Header_Eat.WeightedPred:
	action in2WeightedPred:[x] ==> 
	guard cntTokensPerSH[23] < nbTokensPerSH[23]
	do
		cntTokensPerSH[23] := cntTokensPerSH[23] + 1;
	end
	
	p2.Header_Eat.TileSize:
	action in2TileSize:[x] repeat 2 ==> 
	guard cntTokensPerSH[24] < nbTokensPerSH[24]
	do
		cntTokensPerSH[24] := cntTokensPerSH[24] + 2;
	end	

/*--------------------- p2.Data ---------------------*/	
	p2.Data.CUInfo:
	action in2CUInfo:[x] repeat 5 ==> opCUInfo:[x] repeat 5
	guard cntTokensPerCTU[0] < nbTokensPerCTU[0] 
	do
		cntTokensPerCTU[0] := cntTokensPerCTU[0] + 5;
	end

	p2.Data.IntraPredMode:
	action in2IntraPredMode:[x] repeat 2 ==> opIntraPredMode:[x] repeat 2 
	guard cntTokensPerCTU[1] < nbTokensPerCTU[1] 
	do
		cntTokensPerCTU[1] := cntTokensPerCTU[1] + 2;
	end
	
	p2.Data.PartMode:
	action in2PartMode:[x] ==> opPartMode:[x]
	guard cntTokensPerCTU[2] < nbTokensPerCTU[2] 
	do
		cntTokensPerCTU[2] := cntTokensPerCTU[2] + 1;
	end
	
	p2.Data.IsPicSlcLcu:
	action in2IsPicSlcLcu:[x] ==> opIsPicSlcLcu:[x]
	guard cntTokensPerCTU[3] < nbTokensPerCTU[3] 
	do
		cntTokensPerCTU[3] := cntTokensPerCTU[3] + 1;
	end

	p2.Data.SaoSe:
	action in2SaoSe:[x] ==> opSaoSe:[x]
	guard cntTokensPerCTU[4] < nbTokensPerCTU[4] 
	do
		cntTokensPerCTU[4] := cntTokensPerCTU[4] + 1;
	end

	p2.Data.SplitTransform:
	action in2SplitTransform:[x] ==> opSplitTransform:[x]	
	guard cntTokensPerCTU[5] < nbTokensPerCTU[5] 
	do
		cntTokensPerCTU[5] := cntTokensPerCTU[5] + 1;
	end
	
	p2.Data.TUSize:
	action in2TUSize:[x] repeat 7 ==> opTUSize:[x] repeat 7
	guard cntTokensPerCTU[6] < nbTokensPerCTU[6] 
	do
		cntTokensPerCTU[6] := cntTokensPerCTU[6] + 7;
	end

	p2.Data.Coeff:
	action in2Coeff:[x] repeat 16 ==> opCoeff:[x] repeat 16		
	guard cntTokensPerCTU[7] < nbTokensPerCTU[7] 
	do
		cntTokensPerCTU[7] := cntTokensPerCTU[7] + 16;
	end
	
	p2.Data.MvPredSyntaxElem:
	action in2MvPredSyntaxElem:[x] ==> opMvPredSyntaxElem:[x]
	guard cntTokensPerCTU[8] < nbTokensPerCTU[8] 
	do
		cntTokensPerCTU[8] := cntTokensPerCTU[8] + 1;
	end
	
	p2.Data.Cbf:
	action in2Cbf:[x] ==> opCbf:[x]
	guard cntTokensPerCTU[9] < nbTokensPerCTU[9] 
	do
		cntTokensPerCTU[9] := cntTokensPerCTU[9] + 1;
	end

	p2.Data.TileCUInfo:
	action in2TileCUInfo:[x] repeat 5 ==> opTileCUInfo:[x] repeat 5	
	guard cntTokensPerCTU[10] < nbTokensPerCTU[10] 
	do
		cntTokensPerCTU[10] := cntTokensPerCTU[10] + 5;
	end
	
	p2.Data.Qp:
	action in2Qp:[x] repeat 2 ==> opQp:[x] repeat 2	
	guard cntTokensPerCTU[11] < nbTokensPerCTU[11] 
	do
		cntTokensPerCTU[11] := cntTokensPerCTU[11] + 2;
	end
	
	p2.Data_endCTU:
	action ==>
	do
		cntCTUs := cntCTUs + 1;
//println("p2.Data_ctuFinished");
ifTokenDiffsCTU();
	end	
/*--------------------- State-vars and procedures ---------------------*/
	uint(size=16) cntCTUs := 0;
	uint(size=1) eouFlag := 0;
	int headerControl := 0;
	uint(size=16) nbTokensPerCTU[12] := [0: for int i in 0 .. 11];
	uint(size=16) cntTokensPerCTU[12] := [0: for int i in 0 .. 11];
		
	procedure resetVarsCTU()
	begin
		cntCTUs 		:= 0;
		eouFlag 		:= 0;		
		nbTokensPerCTU	:= [0,0,0,0,0,0,0,0,0,0,0,0];
		cntTokensPerCTU	:= [0,0,0,0,0,0,0,0,0,0,0,0];		
	end

	uint(size=16) nbTokensPerSH[25] := [0: for int i in 0 .. 24];
	uint(size=16) cntTokensPerSH[25] := [0: for int i in 0 .. 24];
	
	procedure ifTokenDiffsSH()
	begin		
		foreach int i in 0 .. 24 do
			if((nbTokensPerSH[i] - cntTokensPerSH[i]) != 0) then
				println("["+i+"] => "+nbTokensPerSH[i]+" - "+cntTokensPerSH[i]+" = "+(nbTokensPerSH[i] - cntTokensPerSH[i]));
			end
			// print("["+i+"] => "+(nbTokensPerSH[i] - cntTokensPerSH[i])+", ");
		end	
		
	end
	
	procedure ifTokenDiffsCTU()
	begin
		foreach int i in 0 .. 11 do
			if((nbTokensPerCTU[i] - cntTokensPerCTU[i]) != 0) then
				println("["+i+"] => "+nbTokensPerCTU[i]+" - "+cntTokensPerCTU[i]+" = "+(nbTokensPerCTU[i] - cntTokensPerCTU[i]));
			end
			// print("["+i+"] => "+(nbTokensPerCTU[i] - cntTokensPerCTU[i])+", ");
		end	
	end	

/*--------------------- p1.Header_Control ---------------------*/
	p1.Header_Control_Fwd:
	action in1HeaderControl:[hc], in1NbTokens:[list] repeat 25 ==>
	guard hc = 1
	do
		headerControl 	:= hc; 
		nbTokensPerSH	:= list;
		cntTokensPerSH	:= [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
		resetVarsCTU();
println("p1.Header_Control_Fwd ");
	end
	
	p1.Header_Control_Eat:
	action in1HeaderControl:[hc], in1NbTokens:[list] repeat 25 ==>
	guard hc = 2 or hc = 4 or hc = 5
	do
		headerControl 	:= hc;
		nbTokensPerSH	:= list;
		cntTokensPerSH	:= [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
		resetVarsCTU();
println("p1.Header_Control_Eat "+headerControl);
	end
		
	p1.Header_Control_noHeader:
	action in1HeaderControl:[hc] ==>
	guard hc = 3
	do
		headerControl 	:= hc;	
		resetVarsCTU();
println("p1.Header_Control_noHeader ");
	end
	
	p1.Header_Eat_Done_HC2:
	action ==> 
	guard headerControl = 2 
	do 
		headerControl := 0; 
	end

	p1.Header_Eat_Done_HC4:
	action ==> 
	guard headerControl = 4 
	do 
		headerControl := 0; 
	end
	
	p1.Header_Eat_Done_HC5:
	action ==> 
	guard headerControl = 5 
	do 
		headerControl := 0; 
	end	
/*--------------------- p2.Header_Control ---------------------*/
	p2.Header_Control_Fwd:
	action in2HeaderControl:[hc], in2NbTokens:[list] repeat 25 ==>
	guard hc = 1	
	do
		headerControl 	:= hc;
		nbTokensPerSH	:= list;
		cntTokensPerSH	:= [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
		resetVarsCTU();
println("p2.Header_Control_Fwd ");
	end
	
	p2.Header_Control_Eat:
	action in2HeaderControl:[hc], in2NbTokens:[list] repeat 25 ==>
	guard hc = 2 or hc = 4 or hc = 5
	do
		headerControl 	:= hc;
		nbTokensPerSH	:= list;
		cntTokensPerSH	:= [0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0];
		resetVarsCTU();
println("p2.Header_Control_Eat "+headerControl);
	end	

	p2.Header_Control_noHeader:
	action in2HeaderControl:[hc] ==>
	guard hc = 3
	do
		headerControl 	:= hc;
		resetVarsCTU();
println("p2.Header_Control_noHeader ");
	end
	
	
	p2.Header_Eat_Done_HC2:
	action ==> 
	guard headerControl = 2 
	do 
		headerControl := 0; 
	end

	p2.Header_Eat_Done_HC4:
	action ==> 
	guard headerControl = 4 
	do 
		headerControl := 0; 
	end
	
	p2.Header_Eat_Done_HC5:
	action ==> 
	guard headerControl = 5 
	do 
		headerControl := 0; 
	end		

/*--------------------- p1.Data_Control ---------------------*/
int counter := 0;
	p1.Data_Control_getNbTokensCTU:
	action in1HeaderControl:[eou], in1NbTokens:[list] repeat 12 ==>
	guard eouFlag = 0
	do
		eouFlag := eou;
		nbTokensPerCTU := list;
		cntTokensPerCTU	:= [0,0,0,0,0,0,0,0,0,0,0,0];
counter := counter + nbTokensPerCTU[0];
println("p1.Data_Control_getNbTokensCTU "+cntCTUs+", "+eouFlag+", "+counter);
	end
		
	p1.Data_Control_unitEnd:
	action ==>
	guard  eouFlag = 1
	do
		resetVarsCTU();
println("p1.Data_Control_unitEnd "+cntCTUs+", "+eouFlag);
	end

/*--------------------- p2.Data_Control ---------------------*/
	p2.Data_Control_getNbTokensCTU:
	action in2HeaderControl:[eou], in2NbTokens:[list] repeat 12 ==>
	guard eouFlag = 0
	do
		eouFlag := eou;
		nbTokensPerCTU := list;
		cntTokensPerCTU	:= [0,0,0,0,0,0,0,0,0,0,0,0];
println("p2.Data_Control_getNbTokensCTU "+cntCTUs+", "+eouFlag);
	end	

	p2.Data_Control_unitEnd:
	action ==>
	guard  eouFlag = 1
	do
		resetVarsCTU();	
println("p2.Data_Control_unitEnd "+cntCTUs+", "+eouFlag);
	end

/*--------------------- FSM ---------------------*/	
	schedule fsm p1_Header_Control:
		p1_Header_Control (p1.Header_Control_Fwd) 	   --> p1_Header_Fwd;
		p1_Header_Control (p1.Header_Control_Eat) 	   --> p1_Header_Eat;
		p1_Header_Control (p1.Header_Control_noHeader) --> p1_Data_Control;
		
		p1_Header_Fwd (p1.Header_Fwd) 				   --> p1_Header_Fwd;
		p1_Header_Fwd (p1.Header_Fwd_Done_SliceAdd)	   --> p1_Data_Control;
		
		p1_Header_Eat (p1.Header_Eat) 			   	   --> p1_Header_Eat;
		p1_Header_Eat (p1.Header_Eat_Done_SliceAdd)    --> p1_Header_Eat_Done;		

		p1_Header_Eat_Done (p1.Header_Eat_Done_HC2)	   --> p1_Data_Control;
		p1_Header_Eat_Done (p1.Header_Eat_Done_HC4)    --> p1_Header_Control;
		p1_Header_Eat_Done (p1.Header_Eat_Done_HC5)    --> p2_Header_Control;

		p1_Data_Control (p1.Data_Control_getNbTokensCTU) --> p1_Data;
		p1_Data_Control (p1.Data_Control_unitEnd) 	     --> p2_Header_Control;
		
		p1_Data   (p1.Data)   				--> p1_Data;
		p1_Data   (p1.Data_endCTU)			--> p1_Data_Control;
//------------------------------------------------------------------------//
		p2_Header_Control (p2.Header_Control_Fwd) 	   --> p2_Header_Fwd;
		p2_Header_Control (p2.Header_Control_Eat) 	   --> p2_Header_Eat;
		p2_Header_Control (p2.Header_Control_noHeader) --> p2_Data_Control;
		
		p2_Header_Fwd (p2.Header_Fwd) 				   --> p2_Header_Fwd;
		p2_Header_Fwd (p2.Header_Fwd_Done_SliceAdd)	   --> p2_Data_Control;
		
		p2_Header_Eat (p2.Header_Eat) 				   --> p2_Header_Eat;
		p2_Header_Eat (p2.Header_Eat_Done_SliceAdd)    --> p2_Header_Eat_Done;

		p2_Header_Eat_Done (p2.Header_Eat_Done_HC2)	   --> p2_Data_Control;
		p2_Header_Eat_Done (p2.Header_Eat_Done_HC4)    --> p2_Header_Control;
		p2_Header_Eat_Done (p2.Header_Eat_Done_HC5)    --> p1_Header_Control;

		p2_Data_Control (p2.Data_Control_getNbTokensCTU) --> p2_Data;
		p2_Data_Control (p2.Data_Control_unitEnd) 	     --> p1_Header_Control;
		
		p2_Data   (p2.Data)   				--> p2_Data;
		p2_Data   (p2.Data_endCTU)			--> p2_Data_Control;
	end
	
	priority
		p1.Header_Fwd  > p1.Header_Fwd_Done_SliceAdd;
		p1.Header_Eat  > p1.Header_Eat_Done_SliceAdd;
		p1.Data   > p1.Data_endCTU;

		p2.Header_Fwd > p2.Header_Fwd_Done_SliceAdd;
		p2.Header_Eat > p2.Header_Eat_Done_SliceAdd;
		p2.Data   > p2.Data_endCTU;
	end

end
