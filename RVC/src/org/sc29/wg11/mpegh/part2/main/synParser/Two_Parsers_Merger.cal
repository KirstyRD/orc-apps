/********************************************************************************

This software module was originally developed by 
Junaid Jameel Ahmad (EPFL), 
in the course of development of the ISO/IEC 23002-5 (Video Tool Library) 
for reference purposes and its performance may not have been optimized. 
This software module is an implementation of one or more tools as 
specified by the ISO/IEC 23002-5.

ISO/IEC gives You a royalty-free, worldwide, non-exclusive, copyright 
license to copy, distribute, and make derivative works of this software 
module or modifications thereof for use in implementations of the 
ISO/IEC 23002-5 in products that satisfy conformance criteria (if any). 

Those intending to use this software module in products are advised that 
its use may infringe existing patents. ISO/IEC have no liability for use 
of this software module or modifications thereof.

Copyright is not released for products that do not conform to audiovisual 
and image-coding related ITU Recommendations and/or ISO/IEC International 
Standards.

Assurance that the originally developed software module can be used 
(1) in the ISO/IEC 23002-5 once the ISO/IEC 23002-5 has been adopted; and 
(2) to develop the ISO/IEC 23002-5: 

EPFL grants ISO/IEC all rights necessary to 
include the originally developed software module or modifications thereof 
in the ISO/IEC 23002-5 and to permit ISO/IEC to offer You a royalty-free, 
worldwide, non-exclusive, copyright license to copy, distribute, and make 
derivative works for use in implementations of the ISO/IEC 23002-5 in 
products that satisfy conformance criteria (if any), and to the extent 
that such originally developed software module or portions of it are 
included in the ISO/IEC 23002-5.  To the extent that EPFL
owns patent rights that would be required to make, use, or 
sell the originally developed software module or portions thereof 
included in the ISO/IEC 23002-5 in a conforming product, EPFL
will assure the ISO/IEC that it is willing to 
negotiate licenses under reasonable and non-discriminatory terms and 
conditions with applicants throughout the world.

ISO/IEC gives You a free license to this software module or modifications 
thereof for the sole  purpose of developing theISO/IEC 23002-5

EPFL retains full right to modify and use the 
code for its own purpose, assign or donate the code to a third party and 
to inhibit third parties from using the code for products that do not 
conform to MPEG-related ITU Recommendations and/or ISO/IEC International 
Standards. 

This copyright notice must be included in all copies or derivative works. 
Copyright (c) ISO/IEC 2011-2014.
*****************************************************************************/

package org.sc29.wg11.mpegh.part2.main.synParser;

actor Two_Parsers_Merger (uint(size=8) NUM_PARSERS)
								// Parser 1 (p1)
                                uint(size=16) in1CUInfo, // Data port
                                uint(size= 6) in1IntraPredMode, // Data port
                                uint(size=16) in1SliceAddr, // Header port
                                uint(size=16) in1TilesCoord, // Header port
                                uint(size=16) in1RealTilesCoord, // Header port
                                uint(size= 8) in1LcuSizeMax, // Header port
                                uint(size= 4) in1PartMode, // Data port
                                uint(size= 4) in1PartModeSH, // Header port
               					uint(size= 2) in1IsPicSlcLcu, // Data port
               					uint(size= 2) in1IsPicSlcLcuSH, // Header port               					
               					uint(size= 2) in1IsPicSlc, // Header port
                				uint(size= 2) in1LFAcrossSlcTile, // Header port
                                uint(size=16) in1PictSize, // Header port
                                 int(size=16) in1Poc, // Header port
                                 int(size= 9) in1SaoSe, // Data port
                                 int(size= 9) in1SaoSeSH, // Header port
                                uint(size= 8) in1SEI_MD5, // Header port
                                uint(size= 2) in1SliceType, // Header port
                                bool          in1SplitTransform, // Data port
                                 int(size= 8) in1TUSize, // Data port
                                 int(size=16) in1Coeff, // Data port
                                bool          in1StrongIntraSmoothing, // Header port
                                uint(size=14) in1DispCoord, // Header port
                                uint(size= 9) in1PicSizeInMb, // Header port
                                uint(size= 5) in1NumRefIdxLxActive, // Header port
                                uint(size= 4) in1RefPicListModif, // Header port
                                 int(size=16) in1RefPoc, // Header port
                                 int(size=16) in1MvPredSyntaxElem, // Data port
                                 int(size=16) in1MvPredSyntaxElemSH, // Header port                                 
                                bool 		  in1Cbf, // Data port
                                bool		  in1DBFDisable, // Header port
                                 int(size= 8) in1DbfSe, // Header port
                                uint(size= 8) in1ReorderPics, // Header port
                                 int(size=16) in1WeightedPred, // Header port
                                uint(size=16) in1TileSize, // Header port
                                uint(size=16) in1TileCUInfo, // Data port
                                 int(size= 8) in1Qp, // Data port
                                 int(size= 8) in1HeaderControl,  // Control port
                                uint(size=16) in1NbTokensPerCTU, // Control port
                                 bool		  in1UnitFinished,   // Control port                                  
                                
								// Parser 2 (p2)
                                uint(size=16) in2CUInfo, // Data port
                                uint(size= 6) in2IntraPredMode, // Data port
                                uint(size=16) in2SliceAddr, // Header port
                                uint(size=16) in2TilesCoord, // Header port
                                uint(size=16) in2RealTilesCoord, // Header port
                                uint(size= 8) in2LcuSizeMax, // Header port
                                uint(size= 4) in2PartMode, // Data port
                                uint(size= 4) in2PartModeSH, // Header port
               					uint(size= 2) in2IsPicSlcLcu, // Data port
               					uint(size= 2) in2IsPicSlcLcuSH, // Header port               					
               					uint(size= 2) in2IsPicSlc, // Header port
                				uint(size= 2) in2LFAcrossSlcTile, // Header port
                                uint(size=16) in2PictSize, // Header port
                                 int(size=16) in2Poc, // Header port
                                 int(size= 9) in2SaoSe, // Data port
                                 int(size= 9) in2SaoSeSH, // Header port
                                uint(size= 8) in2SEI_MD5, // Header port
                                uint(size= 2) in2SliceType, // Header port
                                bool          in2SplitTransform, // Data port
                                 int(size= 8) in2TUSize, // Data port
                                 int(size=16) in2Coeff, // Data port
                                bool          in2StrongIntraSmoothing, // Header port
                                uint(size=14) in2DispCoord, // Header port
                                uint(size= 9) in2PicSizeInMb, // Header port
                                uint(size= 5) in2NumRefIdxLxActive, // Header port
                                uint(size= 4) in2RefPicListModif, // Header port
                                 int(size=16) in2RefPoc, // Header port
                                 int(size=16) in2MvPredSyntaxElem, // Data port
                                 int(size=16) in2MvPredSyntaxElemSH, // Header port                                 
                                bool 		  in2Cbf, // Data port
                                bool		  in2DBFDisable, // Header port
                                 int(size= 8) in2DbfSe, // Header port
                                uint(size= 8) in2ReorderPics, // Header port
                                 int(size=16) in2WeightedPred, // Header port
                                uint(size=16) in2TileSize, // Header port
                                uint(size=16) in2TileCUInfo, // Data port
                                 int(size= 8) in2Qp, // Data port
                                 int(size= 8) in2HeaderControl,  // Control port
                                uint(size=16) in2NbTokensPerCTU, // Control port
                                 bool		  in2UnitFinished    // Control port                                  
                                ==>
                                // Output ports
                                uint(size=16) opCUInfo,
                                uint(size= 6) opIntraPredMode,
                                uint(size=16) opSliceAddr,
                                uint(size=16) opTilesCoord,
                                uint(size=16) opRealTilesCoord,
                                uint(size= 8) opLcuSizeMax,
                                uint(size= 4) opPartMode,
               					uint(size= 2) opIsPicSlcLcu,
               					uint(size= 2) opIsPicSlc,
                				uint(size= 2) opLFAcrossSlcTile,
                                uint(size=16) opPictSize,
                                 int(size=16) opPoc,
                                 int(size= 9) opSaoSe,
                                uint(size= 8) opSEI_MD5,
                                uint(size= 2) opSliceType,
                                bool          opSplitTransform,
                                 int(size= 8) opTUSize,
                                 int(size=16) opCoeff,
                                bool          opStrongIntraSmoothing,
                                uint(size=14) opDispCoord,
                                uint(size= 9)  opPicSizeInMb,
                                uint(size= 5) opNumRefIdxLxActive,
                                uint(size= 4) opRefPicListModif,
                                 int(size=16) opRefPoc,
                                 int(size=16) opMvPredSyntaxElem,
                                bool		  opCbf,
                                bool		  opDBFDisable,
                                 int(size= 8) opDbfSe,
                                uint(size= 8) opReorderPics,
                                 int(size=16) opWeightedPred,
                                uint(size=16) opTileSize,
                                uint(size=16) opTileCUInfo,
                                 int(size= 8) opQp
:

/*--------------------- p1.Header_Fwd ---------------------*/
	p1.Header_Fwd_Done_SliceAdd:
	action in1SliceAddr:[x] repeat 2 ==> opSliceAddr:[x] repeat 2 
do
//println("p1.Header_Fwd_Done_SliceAdd");
	end
	
	p1.Header_Fwd.TilesCoord:
	action in1TilesCoord:[x] ==> opTilesCoord:[x] end
	
	p1.Header_Fwd.RealTilesCoord:
	action in1RealTilesCoord:[x] ==> opRealTilesCoord:[x] end	
	
	p1.Header_Fwd.LcuSizeMax:
	action in1LcuSizeMax:[x] ==> opLcuSizeMax:[x] end

	p1.Header_Fwd.PartModeSH:
	action in1PartModeSH:[x] ==> opPartMode:[x] end

	p1.Header_Fwd.IsPicSlcLcuSH:
	action in1IsPicSlcLcuSH:[x] ==> opIsPicSlcLcu:[x] end
	
	p1.Header_Fwd.IsPicSlc:
	action in1IsPicSlc:[x] ==> opIsPicSlc:[x] end
	
	p1.Header_Fwd.LFAcrossSlcTile:
	action in1LFAcrossSlcTile:[x] ==> opLFAcrossSlcTile:[x] end	
	
	p1.Header_Fwd.PictSize:
	action in1PictSize:[x] repeat 2 ==> opPictSize:[x] repeat 2 end

	p1.Header_Fwd.Poc:
	action in1Poc:[x] ==> opPoc:[x] end
	
	p1.Header_Fwd.SaoSeSH:
	action in1SaoSeSH:[x] ==> opSaoSe:[x] end
	
	p1.Header_Fwd.SEI_MD5:
	action in1SEI_MD5:[x] ==> opSEI_MD5:[x] end

	p1.Header_Fwd.SliceType:
	action in1SliceType:[x] ==> opSliceType:[x] end
	
	p1.Header_Fwd.StrongIntraSmoothing:
	action in1StrongIntraSmoothing:[x] repeat 2 ==> opStrongIntraSmoothing:[x] repeat 2 end
	
	p1.Header_Fwd.DispCoord:
	action in1DispCoord:[x] repeat 4 ==> opDispCoord:[x] repeat 4 end
	
	p1.Header_Fwd.PicSizeInMb:
	action in1PicSizeInMb:[x] repeat 2 ==> opPicSizeInMb:[x] repeat 2 end	
	
	p1.Header_Fwd.NumRefIdxLxActive:
	action in1NumRefIdxLxActive:[x] repeat 2 ==> opNumRefIdxLxActive:[x] repeat 2 end

	p1.Header_Fwd.RefPicListModif:
	action in1RefPicListModif:[x] ==> opRefPicListModif:[x] end
	
	p1.Header_Fwd.RefPoc:
	action in1RefPoc:[x] ==> opRefPoc:[x] end

	p1.Header_Fwd.MvPredSyntaxElemSH:
	action in1MvPredSyntaxElemSH:[x] repeat 2 ==> opMvPredSyntaxElem:[x] repeat 2 end
	
	p1.Header_Fwd.DBFDisable:
	action in1DBFDisable:[x] ==> opDBFDisable:[x] end

	p1.Header_Fwd.DbfSe:
	action in1DbfSe:[x] repeat 4 ==> opDbfSe:[x] repeat 4 end
	
	p1.Header_Fwd.ReorderPics:
	action in1ReorderPics:[x] repeat 7 ==> opReorderPics:[x] repeat 7 end
	
	p1.Header_Fwd.WeightedPred:
	action in1WeightedPred:[x] ==> opWeightedPred:[x] end
	
	p1.Header_Fwd.TileSize:
	action in1TileSize:[x] repeat 2 ==> opTileSize:[x] repeat 2 end		

/*--------------------- p1.Header_Eat ---------------------*/
	p1.Header_Eat_Done_SliceAdd:
	action in1SliceAddr:[x] repeat 2 ==>
do
//println("p1.Header_Eat_Done_SliceAdd");
	end
	
	p1.Header_Eat.TilesCoord:
	action in1TilesCoord:[x] ==> end
	
	p1.Header_Eat.RealTilesCoord:
	action in1RealTilesCoord:[x] ==> end	
	
	p1.Header_Eat.LcuSizeMax:
	action in1LcuSizeMax:[x] ==> end

	p1.Header_Eat.PartModeSH:
	action in1PartModeSH:[x] ==> end

	p1.Header_Eat.IsPicSlcLcuSH:
	action in1IsPicSlcLcuSH:[x] ==> end
	
	p1.Header_Eat.IsPicSlc:
	action in1IsPicSlc:[x] ==> end
	
	p1.Header_Eat.LFAcrossSlcTile:
	action in1LFAcrossSlcTile:[x] ==> end	
	
	p1.Header_Eat.PictSize:
	action in1PictSize:[x] repeat 2 ==> end

	p1.Header_Eat.Poc:
	action in1Poc:[x] ==> end
	
	p1.Header_Eat.SaoSeSH:
	action in1SaoSeSH:[x] ==> end
	
	p1.Header_Eat.SEI_MD5:
	action in1SEI_MD5:[x] ==> end

	p1.Header_Eat.SliceType:
	action in1SliceType:[x] ==> end
	
	p1.Header_Eat.StrongIntraSmoothing:
	action in1StrongIntraSmoothing:[x] repeat 2 ==> end
	
	p1.Header_Eat.DispCoord:
	action in1DispCoord:[x] repeat 4 ==> end
	
	p1.Header_Eat.PicSizeInMb:
	action in1PicSizeInMb:[x] repeat 2 ==> end	
	
	p1.Header_Eat.NumRefIdxLxActive:
	action in1NumRefIdxLxActive:[x] repeat 2 ==> end

	p1.Header_Eat.RefPicListModif:
	action in1RefPicListModif:[x] ==> end
	
	p1.Header_Eat.RefPoc:
	action in1RefPoc:[x] ==> end

	p1.Header_Eat.MvPredSyntaxElemSH:
	action in1MvPredSyntaxElemSH:[x] repeat 2 ==> end
	
	p1.Header_Eat.DBFDisable:
	action in1DBFDisable:[x] ==> end

	p1.Header_Eat.DbfSe:
	action in1DbfSe:[x] repeat 4 ==> end
	
	p1.Header_Eat.ReorderPics:
	action in1ReorderPics:[x] repeat 7 ==> end
	
	p1.Header_Eat.WeightedPred:
	action in1WeightedPred:[x] ==> end
	
	p1.Header_Eat.TileSize:
	action in1TileSize:[x] repeat 2 ==> end

/*--------------------- p1.Data ---------------------*/	
	p1.Data.CUInfo:
	action in1CUInfo:[x] repeat 5 ==> opCUInfo:[x] repeat 5
	guard cntTokensPerCTU[0] < nbTokensPerCTU[0] 
	do
		cntTokensPerCTU[0] := cntTokensPerCTU[0] + 5;
//counter := counter + 1;
//println(counter+" p1.Data.CUInfo "+x[0]+", "+x[1]+", "+x[2]+", "+x[3]+", "+x[4]);		
	end

	p1.Data.IntraPredMode:
	action in1IntraPredMode:[x] repeat 2 ==> opIntraPredMode:[x] repeat 2 
	guard cntTokensPerCTU[1] < nbTokensPerCTU[1] 
	do
		cntTokensPerCTU[1] := cntTokensPerCTU[1] + 2;
	end
	
	p1.Data.PartMode:
	action in1PartMode:[x] ==> opPartMode:[x]
	guard cntTokensPerCTU[2] < nbTokensPerCTU[2] 
	do
		cntTokensPerCTU[2] := cntTokensPerCTU[2] + 1;
	end
	
	p1.Data.IsPicSlcLcu:
	action in1IsPicSlcLcu:[x] ==> opIsPicSlcLcu:[x]
	guard cntTokensPerCTU[3] < nbTokensPerCTU[3] 
	do
		cntTokensPerCTU[3] := cntTokensPerCTU[3] + 1;
	end

	p1.Data.SaoSe:
	action in1SaoSe:[x] ==> opSaoSe:[x]
	guard cntTokensPerCTU[4] < nbTokensPerCTU[4] 
	do
		cntTokensPerCTU[4] := cntTokensPerCTU[4] + 1;
	end

	p1.Data.SplitTransform:
	action in1SplitTransform:[x] ==> opSplitTransform:[x]	
	guard cntTokensPerCTU[5] < nbTokensPerCTU[5] 
	do
		cntTokensPerCTU[5] := cntTokensPerCTU[5] + 1;
	end
	
	p1.Data.TUSize:
	action in1TUSize:[x] repeat 7 ==> opTUSize:[x] repeat 7
	guard cntTokensPerCTU[6] < nbTokensPerCTU[6] 
	do
		cntTokensPerCTU[6] := cntTokensPerCTU[6] + 7;
	end

	p1.Data.Coeff:
	action in1Coeff:[x] repeat 16 ==> opCoeff:[x] repeat 16		
	guard cntTokensPerCTU[7] < nbTokensPerCTU[7] 
	do
		cntTokensPerCTU[7] := cntTokensPerCTU[7] + 16;
	end
	
	p1.Data.MvPredSyntaxElem:
	action in1MvPredSyntaxElem:[x] ==> opMvPredSyntaxElem:[x]
	guard cntTokensPerCTU[8] < nbTokensPerCTU[8] 
	do
		cntTokensPerCTU[8] := cntTokensPerCTU[8] + 1;
	end
	
	p1.Data.Cbf:
	action in1Cbf:[x] ==> opCbf:[x]
	guard cntTokensPerCTU[9] < nbTokensPerCTU[9] 
	do
		cntTokensPerCTU[9] := cntTokensPerCTU[9] + 1;
//counter := counter + 1;		
//println(counter+" p1.Data.Cbf "+x);		
	end
	
	p1.Data.TileCUInfo:
	action in1TileCUInfo:[x] repeat 5 ==> opTileCUInfo:[x] repeat 5	
	guard cntTokensPerCTU[10] < nbTokensPerCTU[10] 
	do
		cntTokensPerCTU[10] := cntTokensPerCTU[10] + 5;
	end
	
	p1.Data.Qp:
	action in1Qp:[x] repeat 2 ==> opQp:[x] repeat 2	
	guard cntTokensPerCTU[11] < nbTokensPerCTU[11] 
	do
		cntTokensPerCTU[11] := cntTokensPerCTU[11] + 2;
	end
	
	p1.Data_endCTU:
	action ==>
	do
		cntCTUs := cntCTUs + 1;
/*		
println("p1.Data_ctuFinished");
foreach int i in 0 .. 11 do
print("["+i+"] => "+cntTokensPerCTU[i]+", ");
end
println();*/
	end	
	
/*--------------------- p2.Header_Fwd ---------------------*/
	p2.Header_Fwd_Done_SliceAdd:
	action in2SliceAddr:[x] repeat 2 ==> opSliceAddr:[x] repeat 2 
do
//println("p2.Header_Fwd_Done_SliceAdd");
	end
	
	p2.Header_Fwd.TilesCoord:
	action in2TilesCoord:[x] ==> opTilesCoord:[x] end
	
	p2.Header_Fwd.RealTilesCoord:
	action in2RealTilesCoord:[x] ==> opRealTilesCoord:[x] end	
	
	p2.Header_Fwd.LcuSizeMax:
	action in2LcuSizeMax:[x] ==> opLcuSizeMax:[x] end

	p2.Header_Fwd.PartModeSH:
	action in2PartModeSH:[x] ==> opPartMode:[x] end

	p2.Header_Fwd.IsPicSlcLcuSH:
	action in2IsPicSlcLcuSH:[x] ==> opIsPicSlcLcu:[x] end
	
	p2.Header_Fwd.IsPicSlc:
	action in2IsPicSlc:[x] ==> opIsPicSlc:[x] end
	
	p2.Header_Fwd.LFAcrossSlcTile:
	action in2LFAcrossSlcTile:[x] ==> opLFAcrossSlcTile:[x] end	
	
	p2.Header_Fwd.PictSize:
	action in2PictSize:[x] repeat 2 ==> opPictSize:[x] repeat 2 end

	p2.Header_Fwd.Poc:
	action in2Poc:[x] ==> opPoc:[x] end
	
	p2.Header_Fwd.SaoSeSH:
	action in2SaoSeSH:[x] ==> opSaoSe:[x] end
	
	p2.Header_Fwd.SEI_MD5:
	action in2SEI_MD5:[x] ==> opSEI_MD5:[x] end

	p2.Header_Fwd.SliceType:
	action in2SliceType:[x] ==> opSliceType:[x] end
	
	p2.Header_Fwd.StrongIntraSmoothing:
	action in2StrongIntraSmoothing:[x] repeat 2 ==> opStrongIntraSmoothing:[x] repeat 2 end
	
	p2.Header_Fwd.DispCoord:
	action in2DispCoord:[x] repeat 4 ==> opDispCoord:[x] repeat 4 end
	
	p2.Header_Fwd.PicSizeInMb:
	action in2PicSizeInMb:[x] repeat 2 ==> opPicSizeInMb:[x] repeat 2 end	
	
	p2.Header_Fwd.NumRefIdxLxActive:
	action in2NumRefIdxLxActive:[x] repeat 2 ==> opNumRefIdxLxActive:[x] repeat 2 end

	p2.Header_Fwd.RefPicListModif:
	action in2RefPicListModif:[x] ==> opRefPicListModif:[x] end
	
	p2.Header_Fwd.RefPoc:
	action in2RefPoc:[x] ==> opRefPoc:[x] end

	p2.Header_Fwd.MvPredSyntaxElemSH:
	action in2MvPredSyntaxElemSH:[x] repeat 2 ==> opMvPredSyntaxElem:[x] repeat 2 end
	
	p2.Header_Fwd.DBFDisable:
	action in2DBFDisable:[x] ==> opDBFDisable:[x] end

	p2.Header_Fwd.DbfSe:
	action in2DbfSe:[x] repeat 4 ==> opDbfSe:[x] repeat 4 end
	
	p2.Header_Fwd.ReorderPics:
	action in2ReorderPics:[x] repeat 7 ==> opReorderPics:[x] repeat 7 end
	
	p2.Header_Fwd.WeightedPred:
	action in2WeightedPred:[x] ==> opWeightedPred:[x] end
	
	p2.Header_Fwd.TileSize:
	action in2TileSize:[x] repeat 2 ==> opTileSize:[x] repeat 2 end		

/*--------------------- p2.Header_Eat ---------------------*/
	p2.Header_Eat_Done_SliceAdd:
	action in2SliceAddr:[x] repeat 2 ==>
do
//println("p2.Header_Eat_Done_SliceAdd");
	end
	
	p2.Header_Eat.TilesCoord:
	action in2TilesCoord:[x] ==> end
	
	p2.Header_Eat.RealTilesCoord:
	action in2RealTilesCoord:[x] ==> end	
	
	p2.Header_Eat.LcuSizeMax:
	action in2LcuSizeMax:[x] ==> end

	p2.Header_Eat.PartModeSH:
	action in2PartModeSH:[x] ==> end

	p2.Header_Eat.IsPicSlcLcuSH:
	action in2IsPicSlcLcuSH:[x] ==> end
	
	p2.Header_Eat.IsPicSlc:
	action in2IsPicSlc:[x] ==> end
	
	p2.Header_Eat.LFAcrossSlcTile:
	action in2LFAcrossSlcTile:[x] ==> end	
	
	p2.Header_Eat.PictSize:
	action in2PictSize:[x] repeat 2 ==> end

	p2.Header_Eat.Poc:
	action in2Poc:[x] ==> end
	
	p2.Header_Eat.SaoSeSH:
	action in2SaoSeSH:[x] ==> end
	
	p2.Header_Eat.SEI_MD5:
	action in2SEI_MD5:[x] ==> end

	p2.Header_Eat.SliceType:
	action in2SliceType:[x] ==> end
	
	p2.Header_Eat.StrongIntraSmoothing:
	action in2StrongIntraSmoothing:[x] repeat 2 ==> end
	
	p2.Header_Eat.DispCoord:
	action in2DispCoord:[x] repeat 4 ==> end
	
	p2.Header_Eat.PicSizeInMb:
	action in2PicSizeInMb:[x] repeat 2 ==> end	
	
	p2.Header_Eat.NumRefIdxLxActive:
	action in2NumRefIdxLxActive:[x] repeat 2 ==> end

	p2.Header_Eat.RefPicListModif:
	action in2RefPicListModif:[x] ==> end
	
	p2.Header_Eat.RefPoc:
	action in2RefPoc:[x] ==> end

	p2.Header_Eat.MvPredSyntaxElemSH:
	action in2MvPredSyntaxElemSH:[x] repeat 2 ==> end
	
	p2.Header_Eat.DBFDisable:
	action in2DBFDisable:[x] ==> end

	p2.Header_Eat.DbfSe:
	action in2DbfSe:[x] repeat 4 ==> end
	
	p2.Header_Eat.ReorderPics:
	action in2ReorderPics:[x] repeat 7 ==> end
	
	p2.Header_Eat.WeightedPred:
	action in2WeightedPred:[x] ==> end
	
	p2.Header_Eat.TileSize:
	action in2TileSize:[x] repeat 2 ==> end		

/*--------------------- p2.Data ---------------------*/	
int counter := 0;
	p2.Data.CUInfo:
	action in2CUInfo:[x] repeat 5 ==> opCUInfo:[x] repeat 5
	guard cntTokensPerCTU[0] < nbTokensPerCTU[0] 
	do
		cntTokensPerCTU[0] := cntTokensPerCTU[0] + 5;
//counter := counter + 1;
//println(counter+" p2.Data.CUInfo "+x[0]+", "+x[1]+", "+x[2]+", "+x[3]+", "+x[4]);		
	end

	p2.Data.IntraPredMode:
	action in2IntraPredMode:[x] repeat 2 ==> opIntraPredMode:[x] repeat 2 
	guard cntTokensPerCTU[1] < nbTokensPerCTU[1] 
	do
		cntTokensPerCTU[1] := cntTokensPerCTU[1] + 2;
	end
	
	p2.Data.PartMode:
	action in2PartMode:[x] ==> opPartMode:[x]
	guard cntTokensPerCTU[2] < nbTokensPerCTU[2] 
	do
		cntTokensPerCTU[2] := cntTokensPerCTU[2] + 1;
	end
	
	p2.Data.IsPicSlcLcu:
	action in2IsPicSlcLcu:[x] ==> opIsPicSlcLcu:[x]
	guard cntTokensPerCTU[3] < nbTokensPerCTU[3] 
	do
		cntTokensPerCTU[3] := cntTokensPerCTU[3] + 1;
	end

	p2.Data.SaoSe:
	action in2SaoSe:[x] ==> opSaoSe:[x]
	guard cntTokensPerCTU[4] < nbTokensPerCTU[4] 
	do
		cntTokensPerCTU[4] := cntTokensPerCTU[4] + 1;
	end

	p2.Data.SplitTransform:
	action in2SplitTransform:[x] ==> opSplitTransform:[x]	
	guard cntTokensPerCTU[5] < nbTokensPerCTU[5] 
	do
		cntTokensPerCTU[5] := cntTokensPerCTU[5] + 1;
	end
	
	p2.Data.TUSize:
	action in2TUSize:[x] repeat 7 ==> opTUSize:[x] repeat 7
	guard cntTokensPerCTU[6] < nbTokensPerCTU[6] 
	do
		cntTokensPerCTU[6] := cntTokensPerCTU[6] + 7;
	end

	p2.Data.Coeff:
	action in2Coeff:[x] repeat 16 ==> opCoeff:[x] repeat 16		
	guard cntTokensPerCTU[7] < nbTokensPerCTU[7] 
	do
		cntTokensPerCTU[7] := cntTokensPerCTU[7] + 16;
	end
	
	p2.Data.MvPredSyntaxElem:
	action in2MvPredSyntaxElem:[x] ==> opMvPredSyntaxElem:[x]
	guard cntTokensPerCTU[8] < nbTokensPerCTU[8] 
	do
		cntTokensPerCTU[8] := cntTokensPerCTU[8] + 1;
	end
	
	p2.Data.Cbf:
	action in2Cbf:[x] ==> opCbf:[x]
	guard cntTokensPerCTU[9] < nbTokensPerCTU[9] 
	do
		cntTokensPerCTU[9] := cntTokensPerCTU[9] + 1;
//counter := counter + 1;		
//println(counter+" p2.Data.Cbf "+x);		
	end

	p2.Data.TileCUInfo:
	action in2TileCUInfo:[x] repeat 5 ==> opTileCUInfo:[x] repeat 5	
	guard cntTokensPerCTU[10] < nbTokensPerCTU[10] 
	do
		cntTokensPerCTU[10] := cntTokensPerCTU[10] + 5;
	end
	
	p2.Data.Qp:
	action in2Qp:[x] repeat 2 ==> opQp:[x] repeat 2	
	guard cntTokensPerCTU[11] < nbTokensPerCTU[11] 
	do
		cntTokensPerCTU[11] := cntTokensPerCTU[11] + 2;
	end
	
	p2.Data_endCTU:
	action ==>
	do
		cntCTUs := cntCTUs + 1;
//println("p2.Data_ctuFinished");
	end	
	
	procedure resetVars()
	begin
		nbCTUs 			:= 0;
		cntCTUs 		:= 0;		
		nbTokensPerCTU	:= [0,0,0,0,0,0,0,0,0,0,0,0];
		cntTokensPerCTU	:= [0,0,0,0,0,0,0,0,0,0,0,0];		
	end
/*--------------------- p1.Header_Control ---------------------*/
	p1.Header_Control_Fwd:
	action in1HeaderControl:[hc] ==>
	guard hc = 1
	do
		resetVars();
println("p1.Header_Control_Fwd");
	end
	
	p1.Header_Control_Eat:
	action in1HeaderControl:[hc] ==>
	guard hc = 2
	do
		resetVars();
println("p1.Header_Control_Eat");
	end
	
	p1.Header_Control_noHeader:
	action in1HeaderControl:[hc] ==>
	guard hc = 3
	do
		resetVars();
println("p1.Header_Control_noHeader");
	end

/*--------------------- p2.Header_Control ---------------------*/
	p2.Header_Control_Fwd:
	action in2HeaderControl:[hc] ==>
	guard hc = 1	
	do
		resetVars();
println("p2.Header_Control_Fwd");
	end
	
	p2.Header_Control_Eat:
	action in2HeaderControl:[hc] ==>
	guard hc = 2
	do
		resetVars();
println("p2.Header_Control_Eat");
	end	

	p2.Header_Control_noHeader:
	action in2HeaderControl:[hc] ==>
	guard hc = 3
	do
		resetVars();
println("p2.Header_Control_noHeader");
	end

/*--------------------- p1.Data_Control ---------------------*/
	uint(size=16) nbCTUs := 0;
	uint(size=16) cntCTUs := 0;
	uint(size=16) nbTokensPerCTU[12] := [0: for int i in 0 .. 11];
	uint(size=16) cntTokensPerCTU[12] := [0: for int i in 0 .. 11];
	
	p1.Data_Control_getNbCtbTile:
	action in1NbTokensPerCTU:[nb] ==>
	guard nbCTUs = 0
	do
		nbCTUs := nb;
		cntCTUs := 0;
println("p1.Data_Control_getNbCtbTile "+cntCTUs+", "+nbCTUs);
	end

	p1.Data_Control_getNbTokensCTU:
	action in1NbTokensPerCTU:[list] repeat 12 ==>
	guard cntCTUs < nbCTUs
	do
		nbTokensPerCTU := list;
		cntTokensPerCTU	:= [0,0,0,0,0,0,0,0,0,0,0,0];
println("p1.Data_Control_getNbTokensCTU "+cntCTUs+", "+nbCTUs);
/*
foreach int i in 0 .. 11 do
print("["+i+"] => "+nbTokensPerCTU[i]+", ");
end
println();*/
	end
		
	p1.Data_Control_unitEnd:
	action ==>
	guard  nbCTUs > 0, cntCTUs = nbCTUs, NUM_PARSERS = 2
	do
		resetVars();	
println("p1.Data_Control_unitEnd "+cntCTUs+", "+nbCTUs);
	end

	p1.Data_Control_unitEnd_loop:
	action ==>
	guard  nbCTUs > 0, cntCTUs = nbCTUs, NUM_PARSERS < 2
	do
		resetVars();	
println("p1.Data_Control_unitEnd_loop "+cntCTUs+", "+nbCTUs);
	end

/*--------------------- p2.Data_Control ---------------------*/
	p2.Data_Control_getNbCtbTile:
	action in2NbTokensPerCTU:[nb] ==>
	guard nbCTUs = 0
	do
		nbCTUs  := nb;
		cntCTUs := 0;
println("p2.Data_Control_getNbCtbTile "+cntCTUs+", "+nbCTUs);
	end

	p2.Data_Control_getNbTokensCTU:
	action in2NbTokensPerCTU:[list] repeat 12 ==>
	guard cntCTUs < nbCTUs
	do
		nbTokensPerCTU := list;
		cntTokensPerCTU	:= [0,0,0,0,0,0,0,0,0,0,0,0];		
println("p2.Data_Control_getNbTokensCTU "+cntCTUs+", "+nbCTUs);
	end	

	p2.Data_Control_unitEnd:
	action ==>
	guard  nbCTUs > 0, cntCTUs = nbCTUs
	do
		resetVars();	
println("p2.Data_Control_unitEnd "+cntCTUs+", "+nbCTUs);
	end

/*--------------------- FSM ---------------------*/	
	schedule fsm p1_Header_Control:
		p1_Header_Control (p1.Header_Control_Fwd) 	   --> p1_Header_Fwd;
		p1_Header_Control (p1.Header_Control_Eat) 	   --> p1_Header_Eat;
		p1_Header_Control (p1.Header_Control_noHeader) --> p1_Data_Control;
		
		p1_Header_Fwd (p1.Header_Fwd) 				   --> p1_Header_Fwd;
		p1_Header_Fwd (p1.Header_Fwd_Done_SliceAdd)	   --> p1_Data_Control;
		
		p1_Header_Eat (p1.Header_Eat) 				   --> p1_Header_Eat;
		p1_Header_Eat (p1.Header_Eat_Done_SliceAdd)	   --> p1_Data_Control;

		p1_Data_Control (p1.Data_Control_getNbCtbTile)   --> p1_Data_Control;
		p1_Data_Control (p1.Data_Control_getNbTokensCTU) --> p1_Data;
		p1_Data_Control (p1.Data_Control_unitEnd) 	     --> p2_Header_Control;
		p1_Data_Control (p1.Data_Control_unitEnd_loop)   --> p1_Header_Control;
		
		p1_Data   (p1.Data)   				--> p1_Data;
		p1_Data   (p1.Data_endCTU)			--> p1_Data_Control;
//------------------------------------------------------------------------//
		p2_Header_Control (p2.Header_Control_Fwd) 	   --> p2_Header_Fwd;
		p2_Header_Control (p2.Header_Control_Eat) 	   --> p2_Header_Eat;
		p2_Header_Control (p2.Header_Control_noHeader) --> p2_Data_Control;
		
		p2_Header_Fwd (p2.Header_Fwd) 				   --> p2_Header_Fwd;
		p2_Header_Fwd (p2.Header_Fwd_Done_SliceAdd)	   --> p2_Data_Control;
		
		p2_Header_Eat (p2.Header_Eat) 				   --> p2_Header_Eat;
		p2_Header_Eat (p2.Header_Eat_Done_SliceAdd)	   --> p2_Data_Control;

		p2_Data_Control (p2.Data_Control_getNbCtbTile)   --> p2_Data_Control;
		p2_Data_Control (p2.Data_Control_getNbTokensCTU) --> p2_Data;
		p2_Data_Control (p2.Data_Control_unitEnd) 	     --> p1_Header_Control;
		
		p2_Data   (p2.Data)   				--> p2_Data;
		p2_Data   (p2.Data_endCTU)			--> p2_Data_Control;
	end
	
	priority
		p1.Header_Fwd > p1.Header_Fwd_Done_SliceAdd;
		p1.Header_Fwd > p1.Header_Eat_Done_SliceAdd;
		p1.Data   > p1.Data_endCTU;

		p2.Header_Fwd > p2.Header_Fwd_Done_SliceAdd;
		p2.Header_Fwd > p2.Header_Eat_Done_SliceAdd;
		p2.Data   > p2.Data_endCTU;
	end

end
