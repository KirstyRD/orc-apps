package fr.irisa.compa.gecos;

@gecos (tile="4",actors="2")
actor sobelEdgeDetection () int(size=32) inArrayAA ==> int(size=32) outArray :

	int N = 16;
	int M = 16;
//	int inArrayAArrayA[N*M];
	//int outArrayArray[N*M];
//	int inArrayAArrayB[N*M];

	@gecos (inArrayAA="2,16,16", outArray="2,16,16")
	sendData: action inArrayAA:[inArrayA] repeat N*M ==> 
					outArray:[outArray] repeat N*M  
	var
		int outArray[N*M],
		int tmp_gradientH,
		int tmp_gradientV,
		int tmp_pixelVal
	do
	
//	foreach int i in 0 .. N-1 do
//		outArray[i*N+0] := 0;
//		outArray[0*N+i] := 0;
//		outArray[i*N+N-1] := 0;
//		outArray[(N-1)*N+i] := 0;
//	end
	   //Applying sobel operator; for each frame; only Y Plane
      foreach int i in 1 .. N-2
      do
		foreach int j in 1 .. M-2
		do
        	tmp_gradientV := (inArrayA[(i-1)*N + (j-1 )] - inArrayA[(i-1)*N + (j+1)] + 2*inArrayA[i*N + (j-1)] - 2*inArrayA [ i*N + (j+1) ] + inArrayA[ (i+1)*N + (j-1)] - inArrayA [ (i+1)*N + (j+1)])/8 ;
        	tmp_gradientH := (inArrayA[(i-1)*N + (j-1)] + 2*inArrayA[(i-1)*N + j] + inArrayA[(i-1)*N + (j+1)] - inArrayA [(i+1)*N + (j-1)] - 2*inArrayA [(i+1)*N + j ]  - inArrayA [(i+1)*N + (j+1)] )/8;
        	tmp_pixelVal := tmp_gradientV + tmp_gradientH;
//        	if ( (pixelVal) < 0 ) then
//				pixelVal := 0;
//			else if (  (pixelVal) >  255 ) then
//				pixelVal := 255;
//			end
//			end
        	outArray[( i - 1 )*N + (j- 1 )] := tmp_pixelVal;
          end
      end 
            			
	end 

end