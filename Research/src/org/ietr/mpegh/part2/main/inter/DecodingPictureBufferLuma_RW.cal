/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */

/**
 * This actor is a picture buffer containing all reference pictures. It sends
 *		samples needed for the inter prediction
 * 
 * 
 * @input IsBiPred : Indicates when the current CU is using Bi-prediction.
 * 
 * @input IsReadOrNewSlc : Indicates if samples are asked from the current RPS
 *		or if there is a new picture.
 * 
 * @input Mv : movement vectors of the current CU.
 * 
 * @input PicSize : size of the current picture.
 * 
 * @input Poc : Picture Order Count of the current slice.
 * 
 * @output PocRef : POC used for the prediction of the current CU.
 * 
 * @input PredCuSize : Size of the largest side of the current CU.
 * 
 * @input Sample : Samples from the Inloop filter. It represents the pixels
 * 		which will be displayed.
 * 
 * 
 * @output Sample : Samples needed for the inter prediction.
 * 
 * 
 * @author Damien de Saint Jorre (EPFL) <damien.desaintjorre@epfl.ch>
 */
package org.ietr.mpegh.part2.main.inter;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

import org.ietr.mpegh.part2.main.inter.DecodingPictureBufferFunctions.*;
//@DEBUG
actor DecodingPictureBufferLuma_RW ()
	uint(size=2)  IsBiPredOrLx,
	uint(size=1)  IsReadOrNewSlc,
	int (size=32) Mv,
	uint(size=16) PicSize,
	int(size=16)  Poc,
	int (size=16) PocRef,
	uint(size=7)  PredCuSize,
	int (size=16) RpsPoc,
	uint(size=8)  Sample,
	uint(size=2)  IsBiPredOrLx2,
	uint(size=1)  IsReadOrNewSlc2,
	int (size=32) Mv2,
	uint(size=16) PicSize2,
	int(size=16)  Poc2,
	int (size=16) PocRef2,
	uint(size=7)  PredCuSize2,
	int (size=16) RpsPoc2,
	uint(size=8)  Sample2
		==>
	uint(size=8)  RefSample,
	uint(size=8)  VID,
	uint(size=8)  RefSample2
		:


	/* /!\ : Check the size of the border. */
	/* Same values have to be used in DecodingPictureBufferFunctions ! */
	uint(size = 16) BORDER_SIZE = 128;
	uint(size = 8) DPB_SIZE = 17;

	uint(size=8)  pictureBuffer[DPB_SIZE][PICT_HEIGHT+2*BORDER_SIZE][PICT_WIDTH+2*BORDER_SIZE];
	int (size=16) pocRef[DPB_SIZE];
	int           isRef[DPB_SIZE];
	bool pocDone[1000] := [false : for int i in 0 .. 999];
	uint pocToIndex[1000] := [0 : for int i in 0 .. 999];
	
	uint currentPocCounter := 0;
	uint currentPocDisplay := 0;
	
	int currentPoc1 := 0;
	int currentPoc2 := 0;	

	int (size=4)  currIdx  := -1;
	int (size=4)  currIdx2 := -1;
	uint(size=6)  picSizeInCu[2];
	uint(size=16) picSize[2];
	uint(size=6)  xIdx;
	uint(size=6)  yIdx;
	uint(size=1)  numPocRef;
	uint(size=3)  nbList;
	uint(size=3)  sizeOfList;
	bool          isNewPicture;
	int idx := 0;
	uint sendx := 0;
	uint sendy := 0;
	
	uint(size=6)  picSizeInCu2[2];
	uint(size=16) picSize2[2];
	uint(size=6)  xIdx2;
	uint(size=6)  yIdx2;
	uint(size=1)  numPocRef2;
	uint(size=3)  nbList2;
	uint(size=3)  sizeOfList2;
	bool          isNewPicture2;
	int idx2 := 3;
	
	@optimize_c(condition="defined(SSE_ENABLE)", name="getmvinfo_dpb_64_luma_orcc")
    procedure getmvinfo_dpb_64_luma_cal(
  	      uint(size= 8) pictureBufferTmp[DPB_SIZE][PICT_HEIGHT+2*BORDER_SIZE][PICT_WIDTH+2*BORDER_SIZE],
  	      uint(size= 8) RefCu[(64 + 7) * (64 + 7)],
  	      uint(size= 3) idx,
  	      uint(size= 8) sideMax, 
  	      int (size=32) xOffset,
  	      int (size=32) yOffset)
    begin
      foreach int y in 0 .. sideMax - 1
	  	do
			foreach int x in 0 .. sideMax - 1
			do
				RefCu[x+y*(sideMax)] := pictureBuffer[idx][y+yOffset][x+xOffset];
			end
		end
    end
  
    @optimize_c(condition="defined(SSE_ENABLE)", name="getmvinfo_dpb_32_luma_orcc")
    procedure getmvinfo_dpb_32_luma_cal(
  	      uint(size= 8) pictureBufferTmp[DPB_SIZE][PICT_HEIGHT+2*BORDER_SIZE][PICT_WIDTH+2*BORDER_SIZE],
  	      uint(size= 8) RefCu[(32 + 7) * (32 + 7)],
  	      uint(size= 3) idx,
  	      uint(size= 8) sideMax, 
  	      int (size=32) xOffset,
  	      int (size=32) yOffset)
    begin
      foreach int y in 0 .. sideMax - 1
		do
			foreach int x in 0 .. sideMax - 1
			do
				RefCu[x+y*(sideMax)] := pictureBuffer[idx][y+yOffset][x+xOffset];
			end
		end
    end
  
    @optimize_c(condition="defined(SSE_ENABLE)", name="getmvinfo_dpb_16_luma_orcc")
    procedure getmvinfo_dpb_16_luma_cal(
  	      uint(size= 8) pictureBufferTmp[DPB_SIZE][PICT_HEIGHT+2*BORDER_SIZE][PICT_WIDTH+2*BORDER_SIZE],
  	      uint(size= 8) RefCu[(16 + 7) * (16 + 7)],
  	      uint(size= 3) idx,
  	      uint(size= 8) sideMax, 
  	      int (size=32) xOffset,
  	      int (size=32) yOffset)
    begin
      foreach int y in 0 .. sideMax - 1
		do
			foreach int x in 0 .. sideMax - 1
			do
				RefCu[x+y*(sideMax)] := pictureBuffer[idx][y+yOffset][x+xOffset];
			end
		end
    end
  
    @optimize_c(condition="defined(SSE_ENABLE)", name="getmvinfo_dpb_8_luma_orcc")
    procedure getmvinfo_dpb_8_luma_cal(
  	      uint(size= 8) pictureBufferTmp[DPB_SIZE][PICT_HEIGHT+2*BORDER_SIZE][PICT_WIDTH+2*BORDER_SIZE],
  	      uint(size= 8) RefCu[(8 + 7) * (8 + 7)],
  	      uint(size= 3) idx,
  	      uint(size= 8) sideMax, 
  	      int (size=32) xOffset,
  	      int (size=32) yOffset)
    begin
    foreach int y in 0 .. sideMax - 1
		do
			foreach int x in 0 .. sideMax - 1
			do
				RefCu[x+y*(sideMax)] := pictureBuffer[idx][y+yOffset][x+xOffset];
			end
		end
    end
    
    bool isFirstPic := true;
    
    firstPic : action IsReadOrNewSlc:[isRead], PicSize:[picWidthInPix,
		picHeightInPix], Poc:[poc] ==>
	guard
		idx = 0
	do
		println("newpict1");
		picSizeInCu[0] := (picWidthInPix+15)/16;
		picSizeInCu[1] := (picHeightInPix+15)/16;
		picSize[0] := picWidthInPix;
		picSize[1] := picHeightInPix;
		xIdx := 0;
		yIdx := 0;
		foreach uint i in 0 .. DPB_SIZE - 1
		do
			if(isRef[i] = 0) then
				currIdx := i;
			end
		end
		println("currIdx= " + currIdx);
		isRef[currIdx]  := 1;
		pocRef[currIdx] := poc;
		currentPoc1 := poc;
		isNewPicture    := true;
		nbList          := 0;
				
		idx := 1;
	end
	
	/** Getting informations from new slice/picture. Updating these informations **/
	isNewSlice: action IsReadOrNewSlc:[isRead], PicSize:[picWidthInPix,
		picHeightInPix], Poc:[poc] ==>
	guard
		/* Fix me : We should know when there is a new picture */
		idx = 3, isRead = 0 and if(currIdx = -1) then false else poc = pocRef[currIdx]end
	do
		isNewPicture := false;
		nbList := 0;
		idx := 4;
		currentPoc1 := poc;
	end
	
	isNewPict: action IsReadOrNewSlc:[isRead], PicSize:[picWidthInPix,
		picHeightInPix], Poc:[poc] ==>
	guard
		idx = 3, isRead = 0 and not(if(currIdx = -1) then false else poc = pocRef[currIdx]end)
	do
		println("newpict1");
//		println("Dpb ; Pict num "+pictNum);
		picSizeInCu[0] := (picWidthInPix+15)/16;
		picSizeInCu[1] := (picHeightInPix+15)/16;
		picSize[0] := picWidthInPix;
		picSize[1] := picHeightInPix;
		xIdx := 0;
		yIdx := 0;
		foreach uint i in 0 .. DPB_SIZE - 1
		do
			if(isRef[i] = 0) then
				currIdx := i;
			end
		end
		println("currIdx= " + currIdx);
		isRef[currIdx]  := 1;
		pocRef[currIdx] := poc;
		currentPoc1 := poc;
		isNewPicture    := true;
		nbList          := 0;
		//isStillRef := [false: for int i in 0 .. DPB_SIZE - 1];
		idx := 4;
	end

	/** We get all the references from the 5 lists of the Rps
	 * (StCurrentBefore, StCurrentAfter, StFollowing, LtCurrent, LtFollowing)
	 **/
	getRps_launch: action RpsPoc:[numPic]==>
	guard
		(idx = 1 or idx = 4) , nbList < 5
	do
		sizeOfList := numPic;
		idx := 2;
	end

	getRps_done_notFirstFullFrame: action ==>
	guard
		idx = 4, nbList = 5, isNewPicture = true
	do
		println("getRps_done_trueFull");
		isRef[currIdx] := isRef[currIdx] + 1;
		idx := 7;
	end
	
	getRps_done_notFirstNotFullFrame: action ==>
	guard
		idx = 4, nbList = 5, isNewPicture = false
	do
		println("getRps_done_trueNotFull");
		isRef[currIdx] := isRef[currIdx] + 1;
		idx := 3;
	end
	
	getRps_done_first: action ==>
	guard
		idx = 1, nbList = 5
	do
		println("getRps_done_first");
		//isRef[currIdx] := isRef[currIdx] + 1;
		idx := 7;
	end

	/** For each we check the index of the reference poc
	 * (in order to not remove them from the Dpb).
	 **/
	getRpsPoc_launch: action RpsPoc:[pocVal] ==>
	guard
		idx = 2 , sizeOfList > 0
	do
		sizeOfList := sizeOfList - 1;
		foreach int i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = pocVal)then
				isRef[i] := isRef[i] + 1;
			end
		end
	end

	getRpsPoc_done: action ==>
	guard
		idx = 2, sizeOfList = 0
	do
		nbList := nbList + 1;
		idx := 1;
	end

	/* We get the whole Cu decoded (luma and chroma components) and we save
	 * it in the Dpb (pictureBuffer).
	 */
	getCuPix_launch: action Sample:[samp] repeat 16*16 ==>
	guard
		idx = 7, yIdx < picSizeInCu[1]
	var
		int xPixIdx,
		int yPixIdx
	do
		xPixIdx := BORDER_SIZE + xIdx*16;
		yPixIdx := BORDER_SIZE + yIdx*16;
		
		copy_cu_dpb_luma_cal(
          samp,
  	      pictureBuffer,
  	      xPixIdx,
  	      yPixIdx,
  	      currIdx);
  	    
		xIdx := xIdx + 1;
		if(xIdx = picSizeInCu[0]) then
			xIdx := 0;
			yIdx := yIdx + 1;
		end
	end
	
	getCuPix_done: action ==>
	guard
		idx = 7, yIdx = picSizeInCu[1]
	var
		int xSize := picSize[0],
		int ySize := picSize[1]
	do
		println("cuPixDone");
		/* Fill in luma border */
		println("currIdx = " + currIdx);
		fillBorder_luma_cal(
			pictureBuffer,
			currIdx,
			xSize,
			ySize,
			BORDER_SIZE);
			
		pocDone[currentPocCounter] := true;
		println("currentPocCounter = " + currentPocCounter);
		currentPocCounter := currentPocCounter + 1;
		pocToIndex[pocRef[currIdx]] := currIdx;
		xIdx := 0;
		yIdx := 0;
		if isFirstPic then
			idx := 3;
		else
			idx := 8;
		end
		isFirstPic := false;
		//savedPoc[currentPoc] := true;
	end

	/* When we get the picture we add the border (in order to be able to give a
	 * reference pixels which can be outside of the picture).
	 */
	
	sendData: action ==> VID:[CU] repeat 16*16
	guard
		(idx = 3 or idx2 = 3),
		sendy < picSizeInCu[1],
		pocDone[currentPocDisplay] = true
	var
		uint (size=8) CU[16*16]
	do
		//println("sendluma1");
		foreach int i in 0 .. 15 do	
			foreach int j in 0 .. 15 do
				CU[i*16 + j] := pictureBuffer[pocToIndex[currentPocDisplay]][BORDER_SIZE + sendy * 16 + i ][BORDER_SIZE + sendx * 16 + j];
			end
		end
		//println("sendataIdx = " + pocToIndex[currentPocDisplay]);		
		sendx := sendx + 1;
		if(sendx = picSizeInCu[0]) then
			sendx := 0;
			sendy := sendy + 1;
		end
	end
	
	sendDataDone: action ==>
	guard
		(idx = 3 or idx2 = 3),
		sendy = picSizeInCu[1],
		pocDone[currentPocDisplay] = true
	do
		println("sendDdataDone");
		println("pocToIndex[currentPocDisplay] = " + pocToIndex[currentPocDisplay]);
		println("idx2 := " + idx2);
		sendx := 0;
		sendy := 0;
		pocDone[currentPocDisplay] := false;
		currentPocDisplay := currentPocDisplay + 1;
	end
	
	getReadAddr: action IsReadOrNewSlc:[isRead], IsBiPredOrLx:[isBiPredOrLx] ==>
	guard
		idx = 3, isRead = 1, currentPoc1 <= currentPocCounter
	do
		numPocRef :=
			if(isBiPredOrLx = BI_PRED) then
				2
			else
				1
			end;
		idx := 8;
	end
	
//	getReadAddrWait: action IsReadOrNewSlc:[isRead], IsBiPredOrLx:[isBiPredOrLx] ==>
//	guard
//		idx = 3, isRead = 1, currentPoc1 > currentPocCounter
//	do
//		numPocRef :=
//			if(isBiPredOrLx = BI_PRED) then
//				2
//			else
//				1
//			end;
//		idx := 8;
//	end
	
	/* We get all the informations needed for sending the reference Cu. We save
	 * these samples in RefCu, it will be sent with the actions sendCu.isYxY
	 */
	getMvInfo_launch_is64: action PocRef:[poc], PredCuSize:[predCuSize],
		Mv:[mvX, mvY] ==> RefSample:[RefCu] repeat (64+7)*(64+7)
	guard
		idx = 8, numPocRef != 0 && predCuSize = 64
	var
		uint(size=3) idx := 0,
		int (size=32) xOffset,
		int (size=32) yOffset,
		uint(size=7)  sideMax = 64,
		uint(size=8)  RefCu[(64+7)*(64+7)]
	do
		foreach uint i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = poc and isRef[i] > 0) then
				idx := i;
			end
		end
		/* The mv components correspond to the absolute movement vector, that's
		 * why we don't need to add the address of the current Cu
		 */

		/* We remove 3 for each coordinate component, because for the luma
		 * prediction we need the 3 previous pixels
		 */
		xOffset := (mvX >> 2);
		xOffset := min(xOffset, picSize[0]+3);
		xOffset := max(xOffset, -(8 +3 -1) -(sideMax-1));
		xOffset := xOffset +BORDER_SIZE-3;
		yOffset := (mvY >> 2);
		yOffset := min(yOffset, picSize[1]+3);
		yOffset := max(yOffset, -(8 +3 -1) -(sideMax-1));
		yOffset := yOffset +BORDER_SIZE-3;
		/* We also need the 2 next pixels for the prediction, that's why we
		 * add 7 to sideMax
		 */
		getmvinfo_dpb_64_luma_cal(
  	      pictureBuffer,
  	      RefCu,
  	      idx, 
  	      sideMax + 7, 
  	      xOffset,
  	      yOffset);
		numPocRef := numPocRef - 1;
	end
	
	getMvInfo_launch_is32: action PocRef:[poc], PredCuSize:[predCuSize],
		Mv:[mvX, mvY] ==> RefSample:[RefCu] repeat (32+7)*(32+7)
	guard
		idx = 8, numPocRef != 0 && predCuSize = 32
	var
		uint(size=3) idx := 0,
		int (size=32) xOffset,
		int (size=32) yOffset,
		uint(size=7)  sideMax = 32,
		uint(size=8)  RefCu[(32+7)*(32+7)]
	do
		foreach uint i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = poc and isRef[i] > 0) then
				idx := i;
			end
		end
		/* The mv components correspond to the absolute movement vector, that's
		 * why we don't need to add the address of the current Cu
		 */

		/* We remove 3 for each coordinate component, because for the luma
		 * prediction we need the 3 previous pixels
		 */
		xOffset := (mvX >> 2);
		xOffset := min(xOffset, picSize[0]+3);
		xOffset := max(xOffset, -(8 +3 -1) -(sideMax-1));
		xOffset := xOffset +BORDER_SIZE-3;
		yOffset := (mvY >> 2);
		yOffset := min(yOffset, picSize[1]+3);
		yOffset := max(yOffset, -(8 +3 -1) -(sideMax-1));
		yOffset := yOffset +BORDER_SIZE-3;
		/* We also need the 2 next pixels for the prediction, that's why we
		 * add 7 to sideMax
		 */
		getmvinfo_dpb_32_luma_cal(
  	      pictureBuffer,
  	      RefCu,
  	      idx, 
  	      sideMax + 7, 
  	      xOffset,
  	      yOffset);
		numPocRef := numPocRef - 1;
	end
	
	getMvInfo_launch_is16: action PocRef:[poc], PredCuSize:[predCuSize],
		Mv:[mvX, mvY] ==> RefSample:[RefCu] repeat (16+7)*(16+7)
	guard
		idx = 8, numPocRef != 0 && predCuSize = 16
	var
		uint(size=3) idx := 0,
		int (size=32) xOffset,
		int (size=32) yOffset,
		uint(size=7)  sideMax = 16,
		uint(size=8)  RefCu[(16+7)*(16+7)]
	do
		foreach int i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = poc and isRef[i] > 0) then
				idx := i;
			end
		end
		/* The mv components correspond to the absolute movement vector, that's
		 * why we don't need to add the address of the current Cu
		 */

		/* We remove 3 for each coordinate component, because for the luma
		 * prediction we need the 3 previous pixels
		 */
		xOffset := (mvX >> 2);
		xOffset := min(xOffset, picSize[0]+3);
		xOffset := max(xOffset, -(8 +3 -1) -(sideMax-1));
		xOffset := xOffset +BORDER_SIZE-3;
		yOffset := (mvY >> 2);
		yOffset := min(yOffset, picSize[1]+3);
		yOffset := max(yOffset, -(8 +3 -1) -(sideMax-1));
		yOffset := yOffset +BORDER_SIZE-3;
		/* We also need the 2 next pixels for the prediction, that's why we
		 * add 7 to sideMax
		 */
		getmvinfo_dpb_16_luma_cal(
  	      pictureBuffer,
  	      RefCu,
  	      idx, 
  	      sideMax + 7, 
  	      xOffset,
  	      yOffset);
		numPocRef := numPocRef - 1;
	end
	
	getMvInfo_launch_is8: action PocRef:[poc], PredCuSize:[predCuSize],
		Mv:[mvX, mvY] ==> RefSample:[RefCu] repeat (8+7)*(8+7)
	guard
		idx = 8, numPocRef != 0 && predCuSize = 8
	var
		uint(size=3) idx := 0,
		int (size=32) xOffset,
		int (size=32) yOffset,
		uint(size=7)  sideMax = 8,
		uint(size=8)  RefCu[(8+7)*(8+7)]
	do
		foreach uint i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = poc and isRef[i] > 0) then
				idx := i;
			end
		end
		/* The mv components correspond to the absolute motion vector, that's
		 * why we don't need to add the address of the current Cu
		 */

		/* We remove 3 for each coordinate component, because for the luma
		 * prediction we need the 3 previous pixels
		 */
		xOffset := (mvX >> 2);
		xOffset := min(xOffset, picSize[0]+3);
		xOffset := max(xOffset, -(8 +3 -1) -(sideMax-1));
		xOffset := xOffset +BORDER_SIZE-3;
		yOffset := (mvY >> 2);
		yOffset := min(yOffset, picSize[1]+3);
		yOffset := max(yOffset, -(8 +3 -1) -(sideMax-1));
		yOffset := yOffset +BORDER_SIZE-3;
		/* We also need the 2 next pixels for the prediction, that's why we
		 * add 7 to sideMax
		 */
		getmvinfo_dpb_8_luma_cal(
  	      pictureBuffer,
  	      RefCu,
  	      idx, 
  	      sideMax + 7, 
  	      xOffset,
  	      yOffset);
		numPocRef := numPocRef - 1;
	end
	
	getMvInfo_launch_is4: action PocRef:[poc], PredCuSize:[predCuSize],
		Mv:[mvX, mvY] ==> RefSample:[refCu] repeat (4+7)*(4+7)
	guard
		idx = 8, numPocRef != 0 && predCuSize = 4
	var
		uint(size=3) idx := 0,
		int (size=32) xOffset,
		int (size=32) yOffset,
		uint(size=7)  sideMax = 4,
		uint(size=8)  refCu[(4+7)*(4+7)]
	do
		foreach int i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = poc and isRef[i] > 0) then
				idx := i;
			end
		end
		/* The mv components correspond to the absolute movement vector, that's
		 * why we don't need to add the address of the current Cu
		 */

		/* We remove 3 for each coordinate component, because for the luma
		 * prediction we need the 3 previous pixels
		 */
		xOffset := (mvX >> 2);
		xOffset := min(xOffset, picSize[0]+3);
		xOffset := max(xOffset, -(8 +3 -1) -(sideMax-1));
		xOffset := xOffset +BORDER_SIZE-3;
		yOffset := (mvY >> 2);
		yOffset := min(yOffset, picSize[1]+3);
		yOffset := max(yOffset, -(8 +3 -1) -(sideMax-1));
		yOffset := yOffset +BORDER_SIZE-3;
		/* We also need the 2 next pixels for the prediction, that's why we
		 * add 7 to sideMax
		 */
		foreach int y in 0 .. sideMax+7 -1
		do
			foreach int x in 0 .. sideMax+7 -1
			do
				refCu[x+y*(sideMax+7)] := pictureBuffer[idx][y+yOffset][x+xOffset];
			end
		end
		numPocRef := numPocRef - 1;
	end
	
	
	getMvInfo_done: action ==>
	guard
		idx = 8,
		numPocRef = 0
	do
		//println("mvInfoDone");
		idx := 3;
	end


////////////////////////////////////////////////////////////// second frame /////////////////////////////////////////////////////////////////////////////
	bool isFirstPic2 := true;
/** Getting informations from new slice/picture. Updating these informations **/
	isNewSlice2: action IsReadOrNewSlc2:[isRead], PicSize2:[picWidthInPix,
		picHeightInPix], Poc2:[poc] ==>
	guard
		/* Fix me : We should know when there is a new picture */
		idx2 = 3, isRead = 0 and if(currIdx2 = -1) then false else poc = pocRef[currIdx2]end
	do
		isNewPicture2 := false;
		nbList2 := 0;
		idx2 := 4;
		currentPoc2 := poc;
	end
	
	int lastIdx2 := 0;
	
	isNewPict2: action IsReadOrNewSlc2:[isRead], PicSize2:[picWidthInPix,
		picHeightInPix], Poc2:[poc] ==>
	guard
		idx2 = 3, isRead = 0 and not(if(currIdx2 = -1) then false else poc = pocRef[currIdx2]end)
	do
		println("newpict2");
//		println("Dpb ; Pict num "+pictNum);
		picSizeInCu2[0] := (picWidthInPix+15)/16;
		picSizeInCu2[1] := (picHeightInPix+15)/16;
		picSize2[0] := picWidthInPix;
		picSize2[1] := picHeightInPix;
		xIdx2 := 0;
		yIdx2 := 0;
		lastIdx2 := currIdx2;
		foreach uint i in 0 .. DPB_SIZE - 1
		do
			if(isRef[i] = 0) then
				currIdx2 := i;
			end
		end
		println("curridx2 = " + currIdx2);
		isRef[currIdx2]  := 1;
		pocRef[currIdx2] := poc;
		currentPoc2 := poc;
		isNewPicture2    := true;
		nbList2         := 0;
		//isStillRef := [false: for int i in 0 .. DPB_SIZE - 1];
		
		idx2 := 4;
	end

	/** We get all the references from the 5 lists of the Rps
	 * (StCurrentBefore, StCurrentAfter, StFollowing, LtCurrent, LtFollowing)
	 **/
	getRps_launch2: action RpsPoc2:[numPic]==>
	guard
		(idx2 = 1 or idx2 = 4), nbList2 < 5
	do
		sizeOfList2 := numPic;
		idx2 := 2;
	end

	getRps_done_notFirstFullFrame2: action ==>
	guard
		idx2 = 4, nbList2 = 5, isNewPicture2 = true
	do
		println("getRps_done_true2");
		isRef[currIdx2] := isRef[currIdx2] + 1;
		if isFirstPic2 then
			idx2 := 3;
		else
			idx2 := 7;
		end
		isFirstPic2 := false;
	end
	
	getRps_done_notFirstNotFullFrame2: action ==>
	guard
		idx2 = 4, nbList2 = 5, isNewPicture2 = false
	do
		println("getRps_done_true2");
		isRef[currIdx2] := isRef[currIdx2] + 1;
		idx2 := 3;
	end

	/** For each we check the index of the reference poc
	 * (in order to not remove them from the Dpb).
	 **/
	getRpsPoc_launch2: action RpsPoc2:[pocVal] ==>
	guard
		idx2 = 2 , sizeOfList2 > 0
	do
		sizeOfList2 := sizeOfList2 - 1;
		foreach int i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = pocVal)then
				isRef[i] := isRef[i] + 1;
			end
		end
	end

	getRpsPoc_end2: action ==>
	guard
		idx2 = 2, sizeOfList2 = 0
	do
		nbList2 := nbList2 + 1;
		idx2 := 4;
	end

	/* We get the whole Cu decoded (luma and chroma components) and we save
	 * it in the Dpb (pictureBuffer).
	 */
	getCuPix_launch2: action Sample2:[samp] repeat 16*16 ==>
	guard
		idx2 = 7, yIdx2 < picSizeInCu2[1]
		//,usefulPoc2[lastIdx2] = false
	var
		int xPixIdx,
		int yPixIdx
	do
		xPixIdx := BORDER_SIZE + xIdx2*16;
		yPixIdx := BORDER_SIZE + yIdx2*16;
		
		copy_cu_dpb_luma_cal(
          samp,
  	      pictureBuffer,
  	      xPixIdx,
  	      yPixIdx,
  	      lastIdx2);
		xIdx2 := xIdx2 + 1;
		if(xIdx2 = picSizeInCu2[0]) then
			xIdx2 := 0;
			yIdx2 := yIdx2 + 1;
		end
	end

	getCuPix_done2: action ==>
	guard
		idx2 = 7, yIdx2 = picSizeInCu2[1]
	var
		int xSize := picSize2[0],
		int ySize := picSize2[1]
	do
		println("cuPixDone2");
		println("currIdx2 = " + currIdx2);
		/* Fill in luma border */
		fillBorder_luma_cal(
			pictureBuffer,
			lastIdx2,
			xSize,
			ySize,
			BORDER_SIZE);
			
		pocDone[currentPocCounter] := true;
		println("currentPocCounter = " + currentPocCounter);
		currentPocCounter := currentPocCounter + 1;
		pocToIndex[pocRef[lastIdx2]] := lastIdx2;
		println("pocRef[lastIdx2] = " + pocRef[lastIdx2]);
		xIdx := 0;
		yIdx := 0;
		idx2 := 3;
	end

	getReadAddr2: action IsReadOrNewSlc2:[isRead], IsBiPredOrLx2:[isBiPredOrLx] ==>
	guard
		idx2 = 3, isRead = 1, currentPoc2 <= currentPocCounter
	do
		numPocRef2 :=
			if(isBiPredOrLx = BI_PRED) then
				2
			else
				1
			end;
		idx2 := 8;
	end
	
//	getReadAddrWait2: action IsReadOrNewSlc2:[isRead], IsBiPredOrLx2:[isBiPredOrLx] ==>
//	guard
//		idx2 = 3, isRead = 1, currentPoc2 > currentPocCounter
//	do
//		numPocRef :=
//			if(isBiPredOrLx = BI_PRED) then
//				2
//			else
//				1
//			end;
//		idx2 := 8;
//	end
//	

	/* We get all the informations needed for sending the reference Cu. We save
	 * these samples in RefCu, it will be sent with the actions sendCu.isYxY
	 */
	getMvInfo_launch_is64_2: action PocRef2:[poc], PredCuSize2:[predCuSize],
		Mv2:[mvX, mvY] ==> RefSample2:[RefCu] repeat (64+7)*(64+7)
	guard
		idx2 = 8, numPocRef2 != 0 && predCuSize = 64
	var
		uint(size=3) idx := 0,
		int (size=32) xOffset,
		int (size=32) yOffset,
		uint(size=7)  sideMax = 64,
		uint(size=8)  RefCu[(64+7)*(64+7)]
	do
		foreach uint i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = poc and isRef[i] > 0) then
				idx := i;
			end
		end
		/* The mv components correspond to the absolute movement vector, that's
		 * why we don't need to add the address of the current Cu
		 */

		/* We remove 3 for each coordinate component, because for the luma
		 * prediction we need the 3 previous pixels
		 */
		xOffset := (mvX >> 2);
		xOffset := min(xOffset, picSize2[0]+3);
		xOffset := max(xOffset, -(8 +3 -1) -(sideMax-1));
		xOffset := xOffset +BORDER_SIZE-3;
		yOffset := (mvY >> 2);
		yOffset := min(yOffset, picSize2[1]+3);
		yOffset := max(yOffset, -(8 +3 -1) -(sideMax-1));
		yOffset := yOffset +BORDER_SIZE-3;
		/* We also need the 2 next pixels for the prediction, that's why we
		 * add 7 to sideMax
		 */
		getmvinfo_dpb_64_luma_cal(
  	      pictureBuffer,
  	      RefCu,
  	      idx, 
  	      sideMax + 7, 
  	      xOffset,
  	      yOffset);
		numPocRef2 := numPocRef2 - 1;
	end
	
	getMvInfo_launch_is32_2: action PocRef2:[poc], PredCuSize2:[predCuSize],
		Mv2:[mvX, mvY] ==> RefSample2:[RefCu] repeat (32+7)*(32+7)
	guard
		idx2 = 8, numPocRef2 != 0 && predCuSize = 32
	var
		uint(size=3) idx := 0,
		int (size=32) xOffset,
		int (size=32) yOffset,
		uint(size=7)  sideMax = 32,
		uint(size=8)  RefCu[(32+7)*(32+7)]
	do
		foreach uint i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = poc and isRef[i] > 0) then
				idx := i;
			end
		end
		/* The mv components correspond to the absolute movement vector, that's
		 * why we don't need to add the address of the current Cu
		 */

		/* We remove 3 for each coordinate component, because for the luma
		 * prediction we need the 3 previous pixels
		 */
		xOffset := (mvX >> 2);
		xOffset := min(xOffset, picSize2[0]+3);
		xOffset := max(xOffset, -(8 +3 -1) -(sideMax-1));
		xOffset := xOffset +BORDER_SIZE-3;
		yOffset := (mvY >> 2);
		yOffset := min(yOffset, picSize2[1]+3);
		yOffset := max(yOffset, -(8 +3 -1) -(sideMax-1));
		yOffset := yOffset +BORDER_SIZE-3;
		/* We also need the 2 next pixels for the prediction, that's why we
		 * add 7 to sideMax
		 */
		getmvinfo_dpb_32_luma_cal(
  	      pictureBuffer,
  	      RefCu,
  	      idx, 
  	      sideMax + 7, 
  	      xOffset,
  	      yOffset);
		numPocRef2 := numPocRef2 - 1;
	end
	
	getMvInfo_launch_is16_2: action PocRef2:[poc], PredCuSize2:[predCuSize],
		Mv2:[mvX, mvY] ==> RefSample2:[RefCu] repeat (16+7)*(16+7)
	guard
		idx2 = 8, numPocRef2 != 0 && predCuSize = 16
	var
		uint(size=3) idx := 0,
		int (size=32) xOffset,
		int (size=32) yOffset,
		uint(size=7)  sideMax = 16,
		uint(size=8)  RefCu[(16+7)*(16+7)]
	do
		foreach int i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = poc and isRef[i] > 0) then
				idx := i;
			end
		end
		/* The mv components correspond to the absolute movement vector, that's
		 * why we don't need to add the address of the current Cu
		 */

		/* We remove 3 for each coordinate component, because for the luma
		 * prediction we need the 3 previous pixels
		 */
		xOffset := (mvX >> 2);
		xOffset := min(xOffset, picSize2[0]+3);
		xOffset := max(xOffset, -(8 +3 -1) -(sideMax-1));
		xOffset := xOffset +BORDER_SIZE-3;
		yOffset := (mvY >> 2);
		yOffset := min(yOffset, picSize2[1]+3);
		yOffset := max(yOffset, -(8 +3 -1) -(sideMax-1));
		yOffset := yOffset +BORDER_SIZE-3;
		/* We also need the 2 next pixels for the prediction, that's why we
		 * add 7 to sideMax
		 */
		getmvinfo_dpb_16_luma_cal(
  	      pictureBuffer,
  	      RefCu,
  	      idx, 
  	      sideMax + 7, 
  	      xOffset,
  	      yOffset);
		numPocRef2 := numPocRef2 - 1;
	end
	
	getMvInfo_launch_is8_2: action PocRef2:[poc], PredCuSize2:[predCuSize],
		Mv2:[mvX, mvY] ==> RefSample2:[RefCu] repeat (8+7)*(8+7)
	guard
		idx2 = 8, numPocRef2 != 0 && predCuSize = 8
	var
		uint(size=3) idx := 0,
		int (size=32) xOffset,
		int (size=32) yOffset,
		uint(size=7)  sideMax = 8,
		uint(size=8)  RefCu[(8+7)*(8+7)]
	do
		foreach uint i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = poc and isRef[i] > 0) then
				idx := i;
			end
		end
		/* The mv components correspond to the absolute motion vector, that's
		 * why we don't need to add the address of the current Cu
		 */

		/* We remove 3 for each coordinate component, because for the luma
		 * prediction we need the 3 previous pixels
		 */
		xOffset := (mvX >> 2);
		xOffset := min(xOffset, picSize2[0]+3);
		xOffset := max(xOffset, -(8 +3 -1) -(sideMax-1));
		xOffset := xOffset +BORDER_SIZE-3;
		yOffset := (mvY >> 2);
		yOffset := min(yOffset, picSize2[1]+3);
		yOffset := max(yOffset, -(8 +3 -1) -(sideMax-1));
		yOffset := yOffset +BORDER_SIZE-3;
		/* We also need the 2 next pixels for the prediction, that's why we
		 * add 7 to sideMax
		 */
		getmvinfo_dpb_8_luma_cal(
  	      pictureBuffer,
  	      RefCu,
  	      idx, 
  	      sideMax + 7, 
  	      xOffset,
  	      yOffset);
		numPocRef2 := numPocRef2 - 1;
	end
	
	getMvInfo_launch_is4_2: action PocRef2:[poc], PredCuSize2:[predCuSize],
		Mv2:[mvX, mvY] ==> RefSample2:[refCu] repeat (4+7)*(4+7)
	guard
		idx2 = 8, numPocRef2 != 0 && predCuSize = 4
	var
		uint(size=3) idx := 0,
		int (size=32) xOffset,
		int (size=32) yOffset,
		uint(size=7)  sideMax = 4,
		uint(size=8)  refCu[(4+7)*(4+7)]
	do
		foreach int i in 0 .. DPB_SIZE - 1
		do
			if(pocRef[i] = poc and isRef[i] > 0) then
				idx := i;
			end
		end
		/* The mv components correspond to the absolute movement vector, that's
		 * why we don't need to add the address of the current Cu
		 */

		/* We remove 3 for each coordinate component, because for the luma
		 * prediction we need the 3 previous pixels
		 */
		xOffset := (mvX >> 2);
		xOffset := min(xOffset, picSize2[0]+3);
		xOffset := max(xOffset, -(8 +3 -1) -(sideMax-1));
		xOffset := xOffset +BORDER_SIZE-3;
		yOffset := (mvY >> 2);
		yOffset := min(yOffset, picSize2[1]+3);
		yOffset := max(yOffset, -(8 +3 -1) -(sideMax-1));
		yOffset := yOffset +BORDER_SIZE-3;
		/* We also need the 2 next pixels for the prediction, that's why we
		 * add 7 to sideMax
		 */
		foreach int y in 0 .. sideMax+7 -1
		do
			foreach int x in 0 .. sideMax+7 -1
			do
				refCu[x+y*(sideMax+7)] := pictureBuffer[idx][y+yOffset][x+xOffset];
			end
		end
		numPocRef2 := numPocRef2 - 1;
	end

	getMvInfo_done2: action ==>
	guard
		idx2 = 8,
		numPocRef2 = 0
	do
		idx2 := 3;
	end

end
