package org.ietr.mpegh.part2.main.synParser;

import  std.util.Math.*;
import  std.stdio.Source.*;

import  org.sc29.wg11.common.BitstreamReadUtils.*;
import  org.sc29.wg11.common.CabacDecodeBinFunction.*;
import  devel.org.sc29.wg11.mpegh.part2.main.synParser.Algo_ParserUtils.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CabacDecodeBinFunction.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CabacContextConstantHEVC.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CabacContextFunctionHEVC.*;
import  devel.org.sc29.wg11.mpegh.part2.common.CabacParserFunctionHEVC.*;

actor PreParser (uint TILE_INDEX, uint TILE_SPLIT_ENABLE)
// TilesInfo[0]: number of tiles to decode
// TilesInfo[i>0]: increasing indexes of tiles
				uint(size= 8) byte
				==>
				uint(size=16) CUInfo,
				uint(size= 6) IntraPredMode,
				//FIXME default value
				uint(size=16) SliceAddr,
				uint(size=16) TilesCoord,
				uint(size=16) RealTilesCoord,
				uint(size=8)  LcuSizeMax,
				uint(size= 4) PartMode,
				uint(size=2)  IsPicSlcLcu,
				uint(size=2)  LFAcrossSlcTile,
				uint(size=16) PictSize,
				 int(size=16) Poc,
				 int(size= 9) SaoSeLuma,
				 int(size= 9) SaoSeChromaU,
				 int(size= 9) SaoSeChromaV,
				uint(size= 8) SEI_MD5,
				uint(size= 2) SliceType,
				bool          SplitTransform,
				 int(size= 8) TUSize,
				 int(size=16) Coeff,
				bool 		  StrongIntraSmoothing,
				uint(size=14) DispCoord,
				uint(size=9)  PicSizeInMb,
				uint(size= 5) NumRefIdxLxActive,
				uint(size= 4) RefPicListModif,
				 int(size=16) RefPoc,
				 int(size=16) MvPredSyntaxElem,
				bool Cbf,
				bool DBFDisable,
				 int(size=8)  DbfSe,
				 int(size=16) WeightedPredLuma,
				 int(size=16) WeightedPredChroma,
				uint(size=16) TileSize,
				uint(size=16) TileCUInfo,
				 int(size= 8) Qp

:
	uint(size=FIFO_DEPTH) fifo[FIFO_SIZE_ALL];
	uint(size= 2) zeroByte := 0;
	uint(size= 8) se_idx;
	uint(size=32) cnt_i;
	uint(size=10) sps_id;
	uint(size=10) pps_id;
	uint NUM_ENTRY_MAX = 64;
	uint entryOffsetsTab[NUM_ENTRY_MAX];
	//uint(size=8) curr_Tile := TilesInfo[1];
	uint(size=8) TilesInfo[2];


	/**************************************************************************
	 **************************************************************************
	 ********        Bitstream Reader                     *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * search_start_code or getByte
	 *************************************************************************/
	uint counterByte := 0;
	action byte:[ b ] ==>
	guard
		not isFifoFull(fifo)
	var
		uint(size=4) fifo_idx  =  fifo[FIFO_IDX]
	do
			counterByte := counterByte + 1; //localizeAEB := localizeAEB >> 1;
		if b != EPR_VALUE or zeroByte != 3 then
			if b = START_CODE_VALUE and zeroByte = 3 then
				fifo[fifo_idx]      := b + START_CODE_FLAG;
			else
				fifo[fifo_idx]      := b;
			end
			fifo[FIFO_CPT_BITS] := fifo[FIFO_CPT_BITS] + 8;
			if DEBUG_BITSTREAM then
				println("fifo["+fifo_idx+"] := "+b);
			end
			fifo[FIFO_IDX]      := (fifo_idx+1) & (FIFO_SIZE-1);
		else
				if b = EPR_VALUE then //println("AntiEmulationByte");
				//localizeAEB := localizeAEB + 128;
				//println("localize AEB = " + localizeAEB);
			end
		end
		if b = 0 then
			zeroByte := ((zeroByte << 1) + 1) & 0x3;
		else
			zeroByte := 0;
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        NAL UNIT                             *********************
	 **************************************************************************
	 *************************************************************************/
	/**************************************************************************
	 * byte_align_a
	 *************************************************************************/
	byte_align_a : action ==>
	guard
		isFifoFull(fifo)
	do
			byte_align(fifo); //localizeAEB := localizeAEB >> 1;
	end
	/**************************************************************************
	 * search_start_code
	 *************************************************************************/
	start_code.search: action ==>
	guard
		not IsStartCode(fifo) and isFifoFull(fifo)
	do
		flushBits( 8, fifo );
		if DEBUG_BITSTREAM then
			println("start_code.search");
		end
	end
	start_code.done: action ==>
	guard
		IsStartCode(fifo) and isFifoFull(fifo)
	do
		flushBits( 8, fifo);
		if DEBUG_BITSTREAM then
			println("start_code.done");
		end
	end
	/**************************************************************************
	 * read_nal_unit_header
	 *************************************************************************/
		uint temporal_id := 0;
	uint(size= 6) nal_unit_type;

	read_nal_unit_header : action ==>
	guard
		isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		if DEBUG_BITSTREAM then
			println("=========== NAL_UNIT ===========");
				flushBits_name(1, fifo,
				"forbidden_zero_bit                      ");
				vld_u_name(6, fifo, res,
				"nal_unit_type                           ");
			nal_unit_type := res[0];
				flushBits_name(6, fifo,
				"nuh_reserved_zero_6bits                 ");
				vld_u_name(3, fifo, res,
				"nuh_temporal_id_plus1                   ");
		else
			flushBits( 1, fifo );
			vld_u(  6, fifo, res);
			nal_unit_type := res[0];
			flushBits( 6, fifo  );
			vld_u(  3, fifo, res);
				temporal_id := res[0] - 1;
		end
		se_idx := 1;
	end
	/**************************************************************************
	 * look_for.VPS_header
	 *************************************************************************/
	look_for.VPS_header: action ==>
	guard
		nal_unit_type = NAL_VPS
	do
		if DEBUG_PARSER then
			println("=========== Video Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.SEI_header
	 *************************************************************************/
	look_for.SEI_header: action ==>
	guard
		nal_unit_type = NAL_SEI_PREFIX or nal_unit_type = NAL_SEI_SUFFIX
	do
		if DEBUG_PARSER then
			println("=========== SEI message ===========");
		end
	end
	/**************************************************************************
	 * look_for.SPS_header
	 *************************************************************************/
	look_for.SPS_header: action ==>
	guard
		nal_unit_type = NAL_SPS
	do
		if DEBUG_PARSER then
			println("=========== Sequence Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.PPS_header
	 *************************************************************************/
	look_for.PPS_header: action ==>
	guard
		nal_unit_type = NAL_PPS
	do
		if DEBUG_PARSER then
			println("=========== Picture Parameter Set ID:   ===========");
		end
	end
	/**************************************************************************
	 * look_for.Slice_header
	 *************************************************************************/
	look_for.Slice_header: action ==>
	guard
		(nal_unit_type = NAL_TRAIL_R    or
		 nal_unit_type = NAL_TSA_N      or
		 nal_unit_type = NAL_TSA_R      or
		 nal_unit_type = NAL_TRAIL_N    or
		 nal_unit_type = NAL_STSA_N		or
		 nal_unit_type = NAL_STSA_R		or
		 nal_unit_type = NAL_RADL_N		or
		 nal_unit_type = NAL_RADL_R		or
		 nal_unit_type = NAL_RASL_N		or
		 nal_unit_type = NAL_RASL_R		or
		 nal_unit_type = NAL_IDR_N_LP	or
		 nal_unit_type = NAL_BLA_W_LP   or
		 nal_unit_type = NAL_BLA_W_RADL or
		 nal_unit_type = NAL_BLA_N_LP   or
		 nal_unit_type = NAL_IDR_W_DLP  or
		 nal_unit_type = NAL_CRA_NUT    or
		 nal_unit_type = NAL_RASL_R)
	do
		if DEBUG_PARSER then
			println("=========== Slice ===========");
		end
	end
	/**************************************************************************
	 * look_for_other_header
	 *************************************************************************/
	look_for_other_header: action ==>
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Video Parameter Set HEADER           *********************
	 **************************************************************************
	 *************************************************************************/
	uint(size= 3) vps_max_sub_layers_minus1;
	uint(size= 6) vps_max_nuh_reserved_zero_layer_id;
	uint(size= 1) vps_timing_info_present_flag;
	uint(size=10) vps_num_op_sets_minus1;
	uint(size=10) vps_num_hrd_parameters;

	/**************************************************************************
	 * read_VPS_Header.se_idx_1
	 *************************************************************************/
	read_VPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  4, fifo, res, "vps_video_parameter_set_id              ");
		vld_u_name(  2, fifo, res, "vps_reserved_three_2bits                ");
		vld_u_name(  6, fifo, res, "vps_reserved_zero_6bits                 ");
		vld_u_name(  3, fifo, res, "vps_max_sub_layers_minus1               ");
		vps_max_sub_layers_minus1 := res[0];
		vld_u_name(  1, fifo, res, "vps_temporal_id_nesting_flag            ");
		vld_u_name( 16, fifo, res, "vps_reserved_ffff_16bits                ");
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_2
	 *************************************************************************/
	read_VPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		bool profile_present_flag = true,
		uint(size = 32) res[1]
	do
		if (profile_present_flag) then
				vld_u_name(2, fifo, res,
				"XXX_profile_space[]                     ");
				vld_u_name(1, fifo, res,
				"XXX_tier_flag[]                         ");
				vld_u_name(5, fifo, res,
				"XXX_profile_idc[]                       ");
			foreach int i in 0 .. 31 do
					vld_u_name(1, fifo, res,
					"XXX_profile_compatibility_flag[][j]     ");
			end
				vld_u_name(1, fifo, res,
				"general_progressive_source_flag         ");
				vld_u_name(1, fifo, res,
				"general_interlaced_source_flag          ");
				vld_u_name(1, fifo, res,
				"general_non_packed_constraint_flag      ");
				vld_u_name(1, fifo, res,
				"general_frame_only_constraint_flag      ");
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_3
	 *************************************************************************/
	read_VPS_Header.se_idx_3 : action ==>
	guard
		se_idx = 3 and isFifoFull(fifo)
	var
		bool profile_present_flag = true,
		uint(size = 32) res[1]
	do
		if (profile_present_flag) then
			vld_u_name( 16, fifo, res, "XXX_reserved_zero_44bits[0..15]         ");
			vld_u_name( 16, fifo, res, "XXX_reserved_zero_44bits[16..31]        ");
			vld_u_name( 12, fifo, res, "XXX_reserved_zero_44bits[32..43]        ");
		end
		vld_u_name(  8, fifo, res, "general_level_idc                       ");
		cnt_i  := 0;
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_4
	 *************************************************************************/
	bool profile_present_flag := true;
	bool sub_layer_profile_present_flag;
	bool sub_layer_level_present_flag;

	read_VPS_Header.se_idx_4.loop1 : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo),
		cnt_i < vps_max_sub_layers_minus1
	var
		uint(size = 32) res[1]
	do
		res[0] := 0;
		if profile_present_flag then
			vld_u_name(  1, fifo, res, "sub_layer_profile_present_flag[i]       ");
		end
		sub_layer_profile_present_flag := (res[0] = 1);
		vld_u_name(  1, fifo, res, "sub_layer_level_present_flag[i]         ");
		sub_layer_level_present_flag := (res[0] = 1);
		cnt_i := cnt_i + 1;
	end

	read_VPS_Header.se_idx_4.insertedCond : action ==>
	guard
		se_idx = 40 and isFifoFull(fifo)
	do
		if (vps_max_sub_layers_minus1 > 0) then
			foreach int k in vps_max_sub_layers_minus1 .. 7 do
				flushBits_name( 2, fifo,    "reserved_zero_2bits[ i ]                ");
			end
		end
		se_idx := 41;
	end

	read_VPS_Header.se_idx_4.loop2 : action ==>
	guard
		se_idx = 41 and isFifoFull(fifo),
		cnt_i < vps_max_sub_layers_minus1
	var
		uint(size = 32) res[1]
	do
		if (profile_present_flag and sub_layer_profile_present_flag) then
			vld_u_name(  2, fifo, res, "sub_layer_profile_space[i]              ");
			vld_u_name(  1, fifo, res, "sub_layer_tier_flag[i]                  ");
			vld_u_name(  5, fifo, res, "sub_layer_profile_idc[i]                ");
			foreach int j in 0 .. 31 do
					vld_u_name(1, fifo, res,
					"sub_layer_profile_compatibility_flags[i][j]");
			end
				flushBits_name(16, fifo,
				"sub_layer_reserved_zero_16bits[i]         ");
		end
		if (sub_layer_level_present_flag) then
			vld_u_name(  1, fifo, res, "sub_layer_level_idc[i]                  ");
		end
		cnt_i := cnt_i + 1;
	end
	read_VPS_Header.se_idx_4.loop1End : action ==>
	guard
		se_idx = 4 ,
		cnt_i = vps_max_sub_layers_minus1
		do
		cnt_i  := 0;
		se_idx := 40;
	end

	read_VPS_Header.se_idx_4.loop2End : action ==>
	guard
		se_idx = 41 ,
		cnt_i = vps_max_sub_layers_minus1
	do
		se_idx := 42;
		cnt_i := 0;
	end

	read_VPS_Header.se_idx_4.decodeInfoPresentFlag : action ==>
	guard
		se_idx = 42 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "vps_sub_layer_ordering_info_present_flag");
		if res[0] = 1 then
			cnt_i  := 0;
		else
			cnt_i  := vps_max_sub_layers_minus1;
		end
		se_idx := 5;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_5
	 *************************************************************************/
	read_VPS_Header.se_idx_5.loop11 : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo),
		cnt_i < vps_max_sub_layers_minus1 +1
	var
		int(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "vps_max_dec_pic_buffering[i]            ");
		vld_ue_name(    fifo, res, "vps_num_reorder_pics[i]                 ");
		vld_ue_name(    fifo, res, "vps_max_latency_increase[i]             ");
		cnt_i := cnt_i + 1;
	end
	read_VPS_Header.se_idx_5.loopEnd : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo),
		cnt_i = vps_max_sub_layers_minus1 + 1
	var
		uint(size=32) res[1]
	do
		vld_u_name(  6, fifo, res, "vps_max_nuh_reserved_zero_layer_id      ");
		vps_max_nuh_reserved_zero_layer_id := res[0];
		vld_ue_name(    fifo, res, "vps_max_op_sets_minus1                  ");
		vps_num_op_sets_minus1 := res[0];
		cnt_i  := 1;
		cnt_i  := vps_num_op_sets_minus1 + 1; // TODO : bypass layer_id_included_flag()
		se_idx := 6;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_6
	 *************************************************************************/
	read_VPS_Header.se_idx_6.loop : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo),
		cnt_i <= vps_num_op_sets_minus1
	var
		uint(size=32) res[1]
	do
		foreach int(size=8) i in 0 .. vps_max_nuh_reserved_zero_layer_id - 1 do
			vld_u_name(  1, fifo, res, "layer_id_included_flag[][i]             ");
		end
		cnt_i := cnt_i + 1;
	end
	read_VPS_Header.se_idx_6.loopEnd : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo),
		cnt_i = vps_num_op_sets_minus1 + 1
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "vps_timing_info_present_flag            ");
		vps_timing_info_present_flag := res[0];
		if vps_timing_info_present_flag = 1 then
			se_idx := se_idx + 1;
		else
			se_idx := 10;
		end
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_7
	 *************************************************************************/
	read_VPS_Header.se_idx_7 : action ==>
	guard
		se_idx = 7 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name( 32, fifo, res, "vps_num_units_in_tick                   ");
		vld_u_name( 32, fifo, res, "vps_time_scale                          ");
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_8
	 *************************************************************************/
	read_VPS_Header.se_idx_8 : action ==>
	guard
		se_idx = 8 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "vps_poc_proportional_to_timing_flag     ");
		if res[0] = 1 then
			vld_ue_name(    fifo, res, "vps_num_ticks_poc_diff_one_minus1       ");
		end
		vld_ue_name(    fifo, res, "vps_num_hrd_parameters                  ");
		vps_num_hrd_parameters := res[0];
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header.se_idx_9
	 *************************************************************************/
	read_VPS_Header.se_idx_9.loop : action ==>
	guard
		se_idx = 9 and isFifoFull(fifo),
		cnt_i < vps_num_hrd_parameters
	var
		uint(size=32) res[1],
		uint(size= 1) cprms_present_flag := 0
	do
		vld_ue_name(    fifo, res, "hrd_op_set_idx[i]                       ");
		if cnt_i > 0 then
			vld_u_name(  1, fifo, res, "cprms_present_flag[i]                   ");
			cprms_present_flag := res[0];
		end
		if cprms_present_flag = 1 then
			println("not support for vps_num_hrd_parameters != 0");
		end
		cnt_i := cnt_i + 1;
	end
	read_VPS_Header.se_idx_9.loopEnd : action ==>
	guard
		se_idx = 9,
		cnt_i = vps_num_hrd_parameters
	do
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_VPS_Header_done
	 *************************************************************************/
	read_VPS_Header_done : action ==>
	guard
		se_idx = 10 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
			vld_u_name(1, fifo, res,
			"vps_extension_flag                      ");
		if res[0] = 1 then
			println("not support for vps_extension_flag != 0");
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        SEI message                          *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_SEI_Header.se_idx_1
	 *************************************************************************/
	uint(size=16) sei_payloadType;
	uint(size=16) sei_payloadSize;
	uint(size=16) sei_payloadPosition;
	uint(size= 8) sei_idx;
	/**************************************************************************
	 * read_SEI_Header.init
	 *************************************************************************/
	read_SEI_Header.init : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	do
		sei_payloadType     := 0;
		sei_payloadSize     := 0;
		sei_payloadPosition := 0;
		se_idx              := se_idx + 1;
		sei_idx             := 1;
	end
	/**************************************************************************
	 * read_SEI_Header.payload_type
	 *************************************************************************/
	read_SEI_Header.payload_type : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "payload_type                            ");
		sei_payloadType := sei_payloadType + res[0];
		if res[0] != 0xFF then
			se_idx := se_idx + 1;
		end
	end
	/**************************************************************************
	 * read_SEI_Header.payload_size
	 *************************************************************************/
	read_SEI_Header.payload_size : action ==>
	guard
		se_idx = 3 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
			vld_u_name(8, fifo, res,
			"payload_size                            ");
		sei_payloadSize := sei_payloadSize + res[0];
			if res[0] != 0xFF then // sei_payload( payloadType, payloadSize )
			se_idx := se_idx + 1;
		end
	end
	/**************************************************************************
	 * read_SEI_Header.decoded_picture_hash
	 *************************************************************************/
	uint(size= 8) sei_cIdx;
	uint(size= 8) sei_i;
	uint(size= 8) sei_hash_type;
	read_SEI_Header.decoded_picture_hash.init : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo),
		sei_idx = 1 and sei_payloadType = 132
	var
		uint(size=32) res[1]
	do
		if DEBUG_PARSER then
			println("=========== Decoded picture hash SEI message ===========");
		end
		vld_u_name(  8, fifo, res, "hash_type                               ");
		sei_payloadPosition := sei_payloadPosition + 8;
		sei_hash_type       := res[0];
		sei_cIdx            := 0;
		sei_i               := 0;
		sei_idx             := sei_idx + 1;
	end
	read_SEI_Header.decoded_picture_hash.loop : action ==> SEI_MD5:[res[0]]
	guard
		se_idx = 4 and isFifoFull(fifo),
		sei_idx = 2 and sei_payloadType = 132,
		sei_cIdx < 3, /*if sps_chroma_format_idc[sps_id] = 0 then 1 else 3 end,*/
		sei_i    < 16
	var
		uint(size=32) res[1]
	do
		if sei_hash_type = 0 then
			vld_u_name(  8, fifo, res, "picture_md5                             ");
			sei_payloadPosition := sei_payloadPosition +  8;
			sei_i               := sei_i + 1;
				elsif sei_hash_type = 1 then vld_u_name(16, fifo, res,
				"picture_crc                             ");
			sei_payloadPosition := sei_payloadPosition + 16;
			sei_i               := 16;
				elsif sei_hash_type = 2 then vld_u_name(32, fifo, res,
				"picture_checksum                        ");
			sei_payloadPosition := sei_payloadPosition + 32;
			sei_i               := 16;
		end
		if sei_i = 16 then
			sei_i := 0;
			sei_cIdx := sei_cIdx + 1;
				if sei_cIdx = 3

				/*if sps_chroma_format_idc[sps_id] = 0 then 1 else 3 end*/
				then
				se_idx := se_idx + 1;
			end
		end
	end
	/**************************************************************************
	 * read_SEI_Header.sei_payload_end
	 *************************************************************************/
	read_SEI_Header.sei_payload_end : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		if not(isByteAlign(fifo) and sei_payloadPosition = (sei_payloadSize << 3)) then
//			if payload_extension_present( ) then
//				reserved_payload_extension_data
//			end
			vld_u_name(  1, fifo, res, "bit_equal_to_one                        ");
			while not isByteAlign(fifo) do
				vld_u_name(  1, fifo, res, "bit_equal_to_zero                       ");
			end
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SEI_Header.done
	 *************************************************************************/
	read_SEI_Header_done : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "rbsp_trailing_bits");
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Sequence Parameter Set HEADER        *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_SPS_Header.se_idx_1
	 *************************************************************************/
	uint(size= 4) sps_max_sub_layers_minus1[NB_MAX_SPS];
	uint(size=16) sps_pic_width_in_luma_samples[NB_MAX_SPS];
	uint(size=16) sps_pic_height_in_luma_samples[NB_MAX_SPS];
	uint(size= 1) sps_separate_colour_plane_flag[NB_MAX_SPS];
	uint(size= 2) sps_chroma_format_idc[NB_MAX_SPS];

	read_SPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
			vld_u_name(4, fifo, res,
			"sps_video_parameter_set_id              ");
			vld_u_name(3, fifo, res,
			"sps_max_sub_layers_minus1               ");
		sps_max_sub_layers_minus1[sps_id] := res[0];
			vld_u_name(1, fifo, res,
			"sps_temporal_id_nesting_flag            ");
		se_idx := 20;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_20
	 *************************************************************************/
	read_SPS_Header.se_idx_20 : action ==>
	guard
		se_idx = 20 and isFifoFull(fifo)
   var
		bool profile_present_flag = true,
		uint(size = 32) res[1]
	do
		if (profile_present_flag) then
			vld_u_name(  2, fifo, res, "XXX_profile_space[]                     ");
			vld_u_name(  1, fifo, res, "XXX_tier_flag[]                         ");
			vld_u_name(  5, fifo, res, "XXX_profile_idc[]                       ");
			foreach int i in 0 .. 31 do
					vld_u_name(1, fifo, res,
					"XXX_profile_compatibility_flag[][j]     ");
			end
			vld_u_name(  1, fifo, res, "general_progressive_source_flag         ");
			vld_u_name(  1, fifo, res, "general_interlaced_source_flag          ");
			vld_u_name(  1, fifo, res, "general_non_packed_constraint_flag      ");
			vld_u_name(  1, fifo, res, "general_frame_only_constraint_flag      ");
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_20
	 *************************************************************************/
	read_SPS_Header.se_idx_21 : action ==>
	guard
		se_idx = 21 and isFifoFull(fifo)
	   var
		bool profile_present_flag = true,
		uint(size = 32) res[1]
	do
		if (profile_present_flag) then
			vld_u_name( 16, fifo, res, "XXX_reserved_zero_44bits[0..15]         ");
			vld_u_name( 16, fifo, res, "XXX_reserved_zero_44bits[16..31]        ");
			vld_u_name( 12, fifo, res, "XXX_reserved_zero_44bits[32..43]        ");
		end
		vld_u_name(  8, fifo, res, "general_level_idc                       ");
		cnt_i  := 0;
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_22
	 *************************************************************************/
	bool sps_sub_layer_level_present_flag := false;
	bool sps_profile_present_flag := true;
	bool sps_sub_layer_profile_present_flag := false;

	read_SPS_Header.se_idx_22.loop1 : action ==>
	guard
		se_idx = 22 and isFifoFull(fifo),
		cnt_i < sps_max_sub_layers_minus1[sps_id]
	var
		uint(size = 32) res[1]
	do
		res[0] := 0;
		if sps_profile_present_flag then
			vld_u_name(  1, fifo, res, "sub_layer_profile_present_flag[i]       ");
		end
		sps_sub_layer_profile_present_flag := (res[0] = 1);
		vld_u_name(  1, fifo, res, "sub_layer_level_present_flag[i]         ");
		sps_sub_layer_level_present_flag := (res[0] = 1);
		cnt_i := cnt_i + 1;
	end

	read_SPS_Header.se_idx_22.loopEnd1 : action ==>
	guard
		se_idx = 22 and isFifoFull(fifo),
		cnt_i = sps_max_sub_layers_minus1[sps_id]
	do
		cnt_i := 0;
		se_idx := 221;
	end

	read_SPS_Header.se_idx_22.indertedCond : action ==>
	guard
		se_idx = 221 and isFifoFull(fifo)
	do
		if sps_max_sub_layers_minus1[sps_id] > 0 then
			foreach int i in sps_max_sub_layers_minus1[sps_id] .. 7 do
					flushBits_name(2, fifo,
					"reserved_zero_2bits[i]                    ");
			end
		end
		se_idx := 222;
	end

	read_SPS_Header.se_idx_22.loop2 : action ==>
	guard
		se_idx = 222 and isFifoFull(fifo),
		cnt_i < sps_max_sub_layers_minus1[sps_id]
	var
		uint(size = 32) res[1]
	do
		if (sps_profile_present_flag and sps_sub_layer_profile_present_flag) then
			vld_u_name(  2, fifo, res, "sub_layer_profile_space[i]              ");
			vld_u_name(  1, fifo, res, "sub_layer_tier_flag[i]                  ");
			vld_u_name(  5, fifo, res, "sub_layer_profile_idc[i]                ");
			foreach int j in 0 .. 31 do
				vld_u_name(  1, fifo, res, "sub_layer_profile_compatibility_flags[i][j]");
			end
			flushBits_name(16, fifo,    "sub_layer_reserved_zero_16bits[i]         ");
		end
		if (sps_sub_layer_level_present_flag) then
			vld_u_name(  1, fifo, res, "sub_layer_level_idc[i]                  ");
		end
		cnt_i := cnt_i + 1;
	end
	read_SPS_Header.se_idx_22.loopEnd : action ==>
	guard
		se_idx = 222 and isFifoFull(fifo),
		cnt_i = sps_max_sub_layers_minus1[sps_id]
	do
		se_idx := 11;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_1_1
	 *************************************************************************/
	read_SPS_Header.se_idx_1_1 : action ==>
	guard
		se_idx = 11 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "sps_seq_parameter_set_id                ");
		sps_id := res[0];
			vld_ue_name(fifo, res,
			"chroma_format_idc                       ");
		sps_chroma_format_idc[sps_id] := res[0];
		if res[0] = 3 then
				vld_u_name(1, fifo, res,
				"separate_colour_plane_flag              ");
			sps_separate_colour_plane_flag[sps_id] := res[0];
		end
			vld_ue_name(fifo, res,
			"pic_width_in_luma_samples               ");
		sps_pic_width_in_luma_samples[sps_id] := res[0];
			vld_ue_name(fifo, res,
			"pic_height_in_luma_samples              ");
		sps_pic_height_in_luma_samples[sps_id] := res[0];
		se_idx := 2;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_2
	 *************************************************************************/
	uint(size= 8) sps_log2_max_pic_order_cnt_lsb_minus4[NB_MAX_SPS];
	uint(size=32) max_poc_lsb[NB_MAX_SPS];

	read_SPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size=1)  conformance_window_flag
	do
		vld_u_name(  1, fifo, res, "conformance_window_flag                 ");
		conformance_window_flag := res[0];
		if conformance_window_flag = 1 then
				vld_ue_name(fifo, res,
				"conf_win_left_offset                    ");
				vld_ue_name(fifo, res,
				"conf_win_right_offset                   ");
				vld_ue_name(fifo, res,
				"conf_win_top_offset                     ");
				vld_ue_name(fifo, res,
				"conf_win_bottom_offset                  ");
		end
			vld_ue_name(fifo, res,
			"sps_bit_depth_luma_minus8                   ");
			vld_ue_name(fifo, res,
			"sps_bit_depth_chroma_minus8                 ");
			vld_ue_name(fifo, res,
			"log2_max_pic_order_cnt_lsb_minus4       ");
		sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] := res[0];
			max_poc_lsb[sps_id] := 1 <<
			(sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4);
			vld_u_name(1, fifo, res,
			"sps_sub_layer_ordering_info_present_flag");
		if res[0] = 1 then
			cnt_i  := 0;
		else
			cnt_i  := sps_max_sub_layers_minus1[sps_id];
		end
		se_idx := se_idx + 1;
	end

	/**************************************************************************
	 * read_SPS_Header.se_idx_3
	 *************************************************************************/
	read_SPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3 and isFifoFull(fifo),
		cnt_i <= sps_max_sub_layers_minus1[sps_id]
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "sps_max_dec_pic_buffering               ");
		vld_ue_name(    fifo, res, "sps_num_reorder_pics                    ");
		vld_ue_name(    fifo, res, "sps_max_latency_increase                ");
		cnt_i := cnt_i + 1;
	end

	read_SPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3,
		cnt_i = sps_max_sub_layers_minus1[sps_id] + 1
	do
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_4
	 *************************************************************************/
		uint(size= 8) sps_log2_min_coding_block_size[NB_MAX_SPS];
	uint(size= 8) sps_log2_diff_max_min_coding_block_size[NB_MAX_SPS];
		uint(size= 8) sps_log2_min_transform_block_size[NB_MAX_SPS];
	uint(size=16) sps_maxCUWidth[NB_MAX_SPS];
	uint(size=16) sps_addCUDepth[NB_MAX_SPS];

	read_SPS_Header.se_idx_4 : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "log2_min_coding_block_size_minus3       ");
				sps_log2_min_coding_block_size[sps_id] := res[0] + 3;
			vld_ue_name(fifo, res,
			"log2_diff_max_min_coding_block_size     ");
		sps_log2_diff_max_min_coding_block_size[sps_id] := res[0];
			vld_ue_name(fifo, res,
			"log2_min_transform_block_size_minus2    ");
		sps_log2_min_transform_block_size[sps_id] := res[0] + 2;
			vld_ue_name(fifo, res,
			"log2_diff_max_min_transform_block_size  ");
			sps_maxCUWidth[sps_id] := 1 << (Log2MinCbSize +
			sps_log2_diff_max_min_coding_block_size[sps_id]);
		sps_addCUDepth[sps_id] := 0;
			while ((sps_maxCUWidth[sps_id] >>
			sps_log2_diff_max_min_coding_block_size[sps_id]) > (1 <<
			(sps_log2_min_transform_block_size[sps_id] +
			sps_log2_diff_max_min_coding_block_size[sps_id]))) do
			sps_addCUDepth[sps_id] := sps_addCUDepth[sps_id] + 1;
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_5
	 *************************************************************************/
	uint(size= 1) sps_scaling_list_enabled_flag[NB_MAX_SPS];


	read_SPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "max_transform_hierarchy_depth_inter     ");
			vld_ue_name(fifo, res,
			"max_transform_hierarchy_depth_intra     ");
			vld_u_name(1, fifo, res,
			"sps_scaling_list_enabled_flag           ");
		sps_scaling_list_enabled_flag[sps_id] := res[0];

		if sps_scaling_list_enabled_flag[sps_id] = 1 then
			se_idx := 60;
		else
			se_idx := 6;
		end
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_6
	 *************************************************************************/
	uint(size= 1) sps_sample_adaptive_offset_enabled_flag[NB_MAX_SPS];
	uint(size= 8) sps_num_short_term_ref_pic_sets[NB_MAX_SPS];
	uint(size= 1) sps_pcm_enabled_flag[NB_MAX_SPS];
	uint(size= 8) sps_sl[NB_MAX_SPS][4][6][64];
	uint(size= 8) sps_sl_dc[NB_MAX_SPS][2][6];
	int sps_size_id := 0;
	int sps_size_id_matrixCase;
	int sps_matrix_id := 0;
	int sps_coef_num :=0;
	int sps_pos;
	int sps_scaling_list_delta_coef;
	int sps_next_coef;

	read_SPS_Header.se_idx_60 : action ==>
	guard
		se_idx = 60 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 1) sps_scaling_list_data_present_flag
	do
			foreach int matrixId in 0 .. 5 do // 4x4 default is 16
			foreach int i in 0 .. 15 do
				sps_sl[sps_id][0][matrixId][i] := 16;
			end
			sps_sl_dc[sps_id][0][matrixId] := 16; // default for 16x16
			sps_sl_dc[sps_id][1][matrixId] := 16; // default for 32x32
		end
		foreach int i in 0 .. 63 do
			sps_sl[sps_id][1][0][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][1][1][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][1][2][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][1][3][i] := default_scaling_list_inter[i];
			sps_sl[sps_id][1][4][i] := default_scaling_list_inter[i];
			sps_sl[sps_id][1][5][i] := default_scaling_list_inter[i];
			sps_sl[sps_id][2][0][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][2][1][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][2][2][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][2][3][i] := default_scaling_list_inter[i];
			sps_sl[sps_id][2][4][i] := default_scaling_list_inter[i];
			sps_sl[sps_id][2][5][i] := default_scaling_list_inter[i];
			sps_sl[sps_id][3][0][i] := default_scaling_list_intra[i];
			sps_sl[sps_id][3][1][i] := default_scaling_list_inter[i];
		end
		vld_u_name(  1, fifo, res, "sps_scaling_list_data_present_flag      ");
		sps_scaling_list_data_present_flag := res[0];
		if sps_scaling_list_data_present_flag = 1 then
			se_idx := 61;
		else
			se_idx := 6;
		end
	end

	read_SPS_Header.se_idx_61_loopSize_id : action ==>
	guard
		se_idx = 61 and isFifoFull(fifo) , sps_size_id < 4
	do
		if sps_size_id = 3 then sps_size_id_matrixCase := 2; else sps_size_id_matrixCase := 6; end
		se_idx := 62;
	end

	read_SPS_Header.se_idx_61_loopMatrix_id : action ==>
	guard
		se_idx = 62 and isFifoFull(fifo) , sps_matrix_id < sps_size_id_matrixCase
	var
		uint(size=32) res[1],
		int delta,
		int size_id_memcpyCase,
		uint(size= 8) sps_scaling_list_pred_mode_flag[4][6],
		uint(size= 32) sps_scaling_list_dc_coef[2][6]
	do
		vld_u_name(  1, fifo, res, "scaling_list_pred_mode_flag             ");
		sps_scaling_list_pred_mode_flag[sps_size_id][sps_matrix_id] := res[0];
		if sps_scaling_list_pred_mode_flag[sps_size_id][sps_matrix_id] = 0 then
			vld_ue_name(    fifo, res, "delta                                   ");
				delta := res[0]; // Only need to handle non-zero delta. Zero means default, which should already be in the arrays.
				if delta != 0 then // Copy from previous array.
				if (sps_matrix_id - delta < 0) then
					println("Invalid delta in scaling list data");
				end
					if sps_size_id > 0 then
						size_id_memcpyCase := 64;
					else
						size_id_memcpyCase := 16;
					end
				foreach int k in 0 .. size_id_memcpyCase - 1 do
						sps_sl[sps_id][sps_size_id][sps_matrix_id][k] :=
						sps_sl[sps_id][sps_size_id][sps_matrix_id - delta][k];
				end
				if (sps_size_id > 1) then
						sps_sl_dc[sps_id][sps_size_id - 2][sps_matrix_id] :=
						sps_sl_dc[sps_id][sps_size_id - 2][sps_matrix_id - delta];
				end
			end
			sps_matrix_id := sps_matrix_id + 1;
		else
			sps_next_coef := 8;
			sps_coef_num := min(64, (1  <<  (4 + (sps_size_id  <<  1))));
			if (sps_size_id > 1) then
				vld_se_name(    fifo, res, "scaling_list_dc_coef                    ");
				sps_scaling_list_dc_coef[sps_size_id - 2][sps_matrix_id] := res[0] + 8;
					sps_next_coef := sps_scaling_list_dc_coef[sps_size_id -
					2][sps_matrix_id];
				sps_sl_dc[sps_id][sps_size_id - 2][sps_matrix_id] := sps_next_coef;
			end
			se_idx := 63;
			cnt_i := 0;
		end
	end

	read_SPS_Header.se_idx_63_loopNumCoef : action ==>
	guard
		se_idx = 63 and isFifoFull(fifo), cnt_i < sps_coef_num
	var
		uint(size=32) res[1]
	do
		if (sps_size_id = 0) then
			sps_pos := 4 * hevc_diag_scan4x4_y[cnt_i] + hevc_diag_scan4x4_x[cnt_i];
		else
			sps_pos := 8 * hevc_diag_scan8x8_y[cnt_i] + hevc_diag_scan8x8_x[cnt_i];
		end
		vld_se_name(    fifo, res, "scaling_list_delta_coef                 ");
		sps_scaling_list_delta_coef := res[0];
		sps_next_coef := (sps_next_coef + sps_scaling_list_delta_coef + 256) mod 256;
		sps_sl[sps_id][sps_size_id][sps_matrix_id][sps_pos] := sps_next_coef;
		cnt_i := cnt_i +1;
	end

	read_SPS_Header.se_idx_63_loopNumCoefEnd : action ==>
	guard
		se_idx = 63 and isFifoFull(fifo), cnt_i = sps_coef_num
	do
		cnt_i := 0;
		sps_matrix_id := sps_matrix_id + 1;
		se_idx := 62;
	end


	read_SPS_Header.se_idx_62_loopMatrix_id_End : action ==>
	guard
		se_idx = 62 and isFifoFull(fifo) , sps_matrix_id = sps_size_id_matrixCase
	do
		sps_size_id := sps_size_id + 1;
		sps_matrix_id := 0;
		se_idx := 61;
	end

	read_SPS_Header.se_idx_61_size_id_loopEnd : action ==>
	guard
		se_idx = 61 and isFifoFull(fifo) , sps_size_id = 4
	do
		sps_size_id := 0;
		se_idx := 6;
	end


	read_SPS_Header.se_idx_6 : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
			vld_u_name(1, fifo, res,
			"amp_enabled_flag                        ");
			vld_u_name(1, fifo, res,
			"sample_adaptive_offset_enabled_flag     ");
		sps_sample_adaptive_offset_enabled_flag[sps_id] := res[0];
			vld_u_name(1, fifo, res,
			"pcm_enabled_flag                        ");
		sps_pcm_enabled_flag[sps_id] := res[0];
		if sps_pcm_enabled_flag[sps_id] = 1 then
				vld_u_name(4, fifo, res,
				"pcm_sample_bit_depth_luma_minus1        ");
				vld_u_name(4, fifo, res,
				"pcm_sample_bit_depth_chroma_minus1      ");
				vld_ue_name(fifo, res,
				"log2_min_pcm_luma_coding_block_size_minus3");
				vld_ue_name(fifo, res,
				"log2_diff_max_min_pcm_luma_coding_block_size");
				vld_u_name(1, fifo, res,
				"pcm_loop_filter_disable_flag            ");
		end
			vld_ue_name(fifo, res,
			"num_short_term_ref_pic_sets             ");
		sps_num_short_term_ref_pic_sets[sps_id] := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_7
	 *************************************************************************/
	int(size=8) pcRPS[NB_MAX_SPS][NB_MAX_PICS+1][PC_RPS_STRUCT_SIZE];

	read_SPS_Header.se_idx_7.loop : action ==>
	guard
		se_idx = 7 and isFifoFull(fifo),
		cnt_i < sps_num_short_term_ref_pic_sets[sps_id]
	do
		parseShortTermRefPicSet(sps_id, cnt_i, sps_num_short_term_ref_pic_sets[sps_id], fifo, pcRPS);
		cnt_i := cnt_i + 1;
	end
	read_SPS_Header.se_idx_7.loopEnd : action ==>
	guard
		se_idx = 7,
		cnt_i = sps_num_short_term_ref_pic_sets[sps_id]
	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end
	/**************************************************************************
	 * read_SPS_Header.se_idx_8
	 *************************************************************************/
	uint(size= 1) sps_long_term_ref_pics_present_flag[NB_MAX_SPS];
	uint(size= 1) sps_temporal_mvp_enable_flag[NB_MAX_SPS];
	bool          sps_strong_intra_smoothing_enable_flag[NB_MAX_SPS];
	uint(size= 6) sps_num_long_term_ref_pics_sps[NB_MAX_SPS];
	uint(size=16) lt_ref_pic_poc_lsb_sps[32];
	uint(size= 8) used_by_curr_pic_lt_sps_flag[32];

	read_SPS_Header.se_idx_8 : action ==>
	guard
		se_idx = 8 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
			vld_u_name(1, fifo, res,
			"long_term_ref_pics_present_flag         ");
		sps_long_term_ref_pics_present_flag[sps_id] := res[0];
		if res[0] = 1 then
				vld_ue_name(fifo, res,
				"num_long_term_ref_pics_sps              ");
			sps_num_long_term_ref_pics_sps[sps_id] := res[0];
				foreach int i in 0 .. sps_num_long_term_ref_pics_sps[sps_id] - 1
				do
					vld_u_name(sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4,
					fifo, res, "lt_ref_pic_poc_lsb_sps                  ");
				lt_ref_pic_poc_lsb_sps[i] := res[0];
					vld_u_name(1, fifo, res,
					"used_by_curr_pic_lt_sps_flag            ");
				used_by_curr_pic_lt_sps_flag[i] := res[0];
			end
		end
			vld_u_name(1, fifo, res,
			"sps_temporal_mvp_enable_flag            ");
		sps_temporal_mvp_enable_flag[sps_id] := res[0];
			vld_u_name(1, fifo, res,
			"sps_strong_intra_smoothing_enable_flag  ");
		sps_strong_intra_smoothing_enable_flag[sps_id] := res[0] = 1;
			vld_u_name(1, fifo, res,
			"vui_parameters_present_flag             ");
		if res[0] = 1 then
			println("not support for vui_parameters_present_flag != 0");
		end
		se_idx := se_idx + 1;
	end

	/**************************************************************************
	 * read_SPS_Header_done
	 *************************************************************************/
	read_SPS_Header_done : action ==>
	guard
		se_idx = 9 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
			vld_u_name(1, fifo, res,
			"sps_extension_flag                      ");
		if res[0] = 1 then
			println("not support for sps_extension_flag != 0");
		end
	end
	/**************************************************************************
	 **************************************************************************
	 ********        Picture Parameter Set HEADER         *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_PPS_Header.se_idx_1
	 *************************************************************************/
	uint(size= 8) pps_sps_id[NB_MAX_PPS];
	uint(size= 2) pps_tiles_enabled_flag[NB_MAX_PPS];

	read_PPS_Header.se_idx_1 : action ==>
	guard
		se_idx = 1 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "pps_pic_parameter_set_id                ");
		pps_id := res[0];
		vld_ue_name(    fifo, res, "pps_seq_parameter_set_id                ");
		sps_id := res[0];
		pps_sps_id[pps_id] := res[0];
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_2
	 *************************************************************************/
	uint(size= 1) pps_dependent_slice_segments_enabled_flag[NB_MAX_PPS];
	uint(size= 1) pps_output_flag_present_flag[NB_MAX_PPS];
	uint(size= 3) pps_num_extra_slice_header_bits[NB_MAX_PPS];
	uint(size= 1) pps_cabac_init_present_flag[NB_MAX_PPS];
	uint(size= 8) pps_num_ref_idx_l0_default_active_minus1[NB_MAX_PPS];
	uint(size= 8) pps_num_ref_idx_l1_default_active_minus1[NB_MAX_PPS];
	bool          pps_constrained_intra_pred_flag[NB_MAX_PPS];
	uint(size= 1) pps_cu_qp_delta_enabled_flag[NB_MAX_PPS];
	 int(size= 8) pps_cb_qp_offset[NB_MAX_PPS];
	 int(size= 8) pps_cr_qp_offset[NB_MAX_PPS];
	uint(size= 1) pps_slice_chroma_qp_offsets_present_flag[NB_MAX_PPS];
	uint(size= 1) pps_weighted_pred_flag[NB_MAX_PPS];
	uint(size= 1) pps_weighted_bipred_flag[NB_MAX_PPS];
	uint(size= 1) pps_entropy_coding_sync_enabled_flag[NB_MAX_PPS];
	uint(size= 8) pps_num_tile_columns_minus1[NB_MAX_PPS];
	uint(size= 8) pps_num_tile_rows_minus1[NB_MAX_PPS];
	uint(size= 1) pps_uniform_spacing_flag[NB_MAX_PPS];

	read_PPS_Header.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "dependent_slice_segments_enabled_flag   ");
		pps_dependent_slice_segments_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "output_flag_present_flag                ");
		pps_output_flag_present_flag[pps_id]:=res[0];
		vld_u_name(  3, fifo, res, "num_extra_slice_header_bits             ");
		pps_num_extra_slice_header_bits[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "sign_data_hiding_flag                   ");
		vld_u_name(  1, fifo, res, "cabac_init_present_flag                 ");
		pps_cabac_init_present_flag[pps_id] := res[0];
		vld_ue_name(    fifo, res, "num_ref_idx_l0_default_active_minus1    ");
		pps_num_ref_idx_l0_default_active_minus1[pps_id] := res[0];
		vld_ue_name(    fifo, res, "num_ref_idx_l1_default_active_minus1    ");
		pps_num_ref_idx_l1_default_active_minus1[pps_id] := res[0];
		vld_se_name(    fifo, res, "init_qp_minus26                         ");
		vld_u_name(  1, fifo, res, "constrained_intra_pred_flag             ");
		pps_constrained_intra_pred_flag[pps_id] := res[0] != 0;
		vld_u_name(  1, fifo, res, "transform_skip_enabled_flag             ");
		vld_u_name(  1, fifo, res, "cu_qp_delta_enabled_flag                ");
		pps_cu_qp_delta_enabled_flag[pps_id] := res[0];
		if res[0] = 1 then
			vld_ue_name(    fifo, res, "diff_cu_qp_delta_depth                  ");
		end
		vld_se_name(    fifo, res, "pps_cb_qp_offset                        ");
		pps_cb_qp_offset[pps_id] := res[0];
		vld_se_name(    fifo, res, "pps_cr_qp_offset                        ");
		pps_cr_qp_offset[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "pps_slice_chroma_qp_offsets_present_flag");
		pps_slice_chroma_qp_offsets_present_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "weighted_pred_flag                      ");
		pps_weighted_pred_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "weighted_bipred_flag                    ");
		pps_weighted_bipred_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "transquant_bypass_enable_flag           ");
		vld_u_name(  1, fifo, res, "tiles_enabled_flag                      ");
		pps_tiles_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "entropy_coding_sync_enabled_flag        ");
		pps_entropy_coding_sync_enabled_flag[pps_id] := res[0];
		pps_num_tile_columns_minus1[pps_id] := 0;
		pps_num_tile_rows_minus1[pps_id]    := 0;
		pps_uniform_spacing_flag[pps_id]    := 1;
		if pps_tiles_enabled_flag[pps_id] = 1 then
			vld_ue_name(    fifo, res, "num_tile_columns_minus1                 ");
			pps_num_tile_columns_minus1[pps_id] := res[0];
			vld_ue_name(    fifo, res, "num_tile_rows_minus1                    ");
			pps_num_tile_rows_minus1[pps_id] := res[0];
			vld_u_name ( 1, fifo, res, "uniform_spacing_flag                    ");
			pps_uniform_spacing_flag[pps_id] :=res[0];
		end
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end
	/**************************************************************************
	 * read_PPS_Header.se_idx_3
	 *************************************************************************/
	uint(size=16) pps_column_width[NB_MAX_PPS][PICT_WIDTH / MIN_CTB_SIZE_Y];

	read_PPS_Header.se_idx_3.loop : action ==>
	guard
		se_idx = 3  and isFifoFull(fifo),
		pps_uniform_spacing_flag[pps_id] = 0 and cnt_i <= pps_num_tile_columns_minus1[pps_id] - 1
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "column_width[ ]                         ");
		pps_column_width[pps_id][cnt_i] := res[0] + 1;
		if cnt_i >= (PICT_WIDTH / MIN_CTB_SIZE_Y) then
			println("Error read_PPS_Header.se_idx_3.loop : "+cnt_i+" >= "+(PICT_WIDTH / MIN_CTB_SIZE_Y));
		end
		cnt_i := cnt_i + 1;
	end
	read_PPS_Header.se_idx_3.loopEnd : action ==>
	guard
		se_idx = 3,
		pps_uniform_spacing_flag[pps_id] = 0 and cnt_i > pps_num_tile_columns_minus1[pps_id] - 1
	do
		se_idx := se_idx + 1;
		cnt_i  := 0;
	end
	read_PPS_Header.se_idx_3.noLoop : action ==>
	guard
		se_idx = 3,
		pps_uniform_spacing_flag[pps_id] = 1
	do
		se_idx := se_idx + 2;
	end
	/**************************************************************************
	 * read_PPS_Header.se_idx4
	 *************************************************************************/
	uint(size=16) pps_row_height[NB_MAX_PPS][PICT_HEIGHT / MIN_CTB_SIZE_Y];
	uint(size= 1) pps_scaling_list_data_present_flag[NB_MAX_PPS];

	read_PPS_Header.se_idx_4.loop : action ==>
	guard
		se_idx = 4 and isFifoFull(fifo),
		pps_uniform_spacing_flag[pps_id] = 0 and cnt_i <= pps_num_tile_rows_minus1[pps_id] - 1
	var
		uint(size=32) res[1]
	do
		vld_ue_name(    fifo, res, "row_height[ ]                           ");
		pps_row_height[pps_id][cnt_i] := res[0] + 1;
		if cnt_i >= (PICT_HEIGHT / MIN_CTB_SIZE_Y) then
			println("Error read_PPS_Header.se_idx_4.loop : "+cnt_i+" >= "+(PICT_HEIGHT / MIN_CTB_SIZE_Y));
		end
		cnt_i := cnt_i + 1;
	end
	read_PPS_Header.se_idx_4.loopEnd : action ==>
	guard
		se_idx = 4,
		pps_uniform_spacing_flag[pps_id] = 0 and cnt_i > pps_num_tile_rows_minus1[pps_id] - 1
	do
		cnt_i  := 0;
		se_idx := 5;
	end

	read_PPS_Header.se_idx_5 : action ==>
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		if (pps_tiles_enabled_flag[pps_id] = 1) then
			vld_u_name(  1, fifo, res, "loop_filter_across_tiles_enabled_flag   ");
			//pps_loop_filter_across_tile_enabled_flag[pps_id] := res[0];
		end
		vld_u_name(  1, fifo, res, "loop_filter_across_slices_enabled_flag  ");
		pps_loop_filter_across_slice_enabled_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "deblocking_filter_control_present_flag  ");
		pps_deblocking_filter_control_present_flag[pps_id] := res[0];
		deblocking_filter_override_enabled_flag[pps_id] := 0;
		if pps_deblocking_filter_control_present_flag[pps_id] = 1 then
			vld_u_name(  1, fifo, res, "deblocking_filter_override_enabled_flag ");
			deblocking_filter_override_enabled_flag[pps_id] := res[0];
			vld_u_name(  1, fifo, res, "pps_disable_deblocking_filter_flag      ");
			pps_disable_deblocking_filter_flag[pps_id] := res[0];
			if res[0] = 0 then
				vld_se_name(    fifo, res, "pps_beta_offset_div2                    ");
				pps_beta_offset[pps_id] := res[0] << 1;
				vld_se_name(    fifo, res, "pps_tc_offset_div2                      ");
				pps_tc_offset[pps_id] := res[0] << 1;
			end
		end
		vld_u_name(  1, fifo, res, "pps_scaling_list_data_present_flag      ");
		pps_scaling_list_data_present_flag[pps_id] := res[0];
		if pps_scaling_list_data_present_flag[pps_id] = 0 then
			se_idx := 52;
		else
			se_idx := 50;
		end
	end

	/**************************************************************************
	 * read_PPS_Header.se_idx5
	 *************************************************************************/
	uint(size= 1) pps_deblocking_filter_control_present_flag[NB_MAX_PPS];
	uint(size =1) deblocking_filter_override_enabled_flag[NB_MAX_PPS];
	//uint(size= 1) pps_loop_filter_across_tile_enabled_flag[NB_MAX_PPS];
	uint(size= 1) pps_loop_filter_across_slice_enabled_flag[NB_MAX_PPS];
	uint(size= 1) pps_lists_modification_present_flag[NB_MAX_PPS];
	uint(size= 1) pps_slice_segment_header_extension_present_flag[NB_MAX_PPS];
	uint(size= 1) pps_disable_deblocking_filter_flag[NB_MAX_PPS];
	uint(size= 1) pps_beta_offset[NB_MAX_PPS];
	uint(size= 1) pps_tc_offset[NB_MAX_PPS];
	uint(size= 8) pps_sl[NB_MAX_PPS][4][6][64];
	uint(size= 8) pps_sl_dc[NB_MAX_PPS][2][6];
	int pps_matrix_id :=0;
	int pps_size_id := 0;
	int pps_next_coef;
	int pps_coef_num;
	int pps_scaling_list_delta_coef;
	int pps_pos;
	int pps_size_id_matrixCase;

	read_PPS_Header.se_idx_51 : action ==>
	guard
		se_idx = 52 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "lists_modification_present_flag         ");
		pps_lists_modification_present_flag[pps_id] := res[0];
		vld_ue_name(    fifo, res, "log2_parallel_merge_level_minus2        ");
		vld_u_name(  1, fifo, res, "slice_segment_header_extension_present_flag");
		pps_slice_segment_header_extension_present_flag[pps_id] := res[0];
		vld_u_name(  1, fifo, res, "pps_extension_flag                      ");
		if res[0] = 1 then
			println("not support for pps_extension_flag != 0");
		end
		se_idx := 6;
	end

	read_PPS_Header.se_idx_50 : action ==>
	guard
		se_idx = 50 and isFifoFull(fifo)
	do
		foreach int matrixId in 0 .. 5 do
			// 4x4 default is 16
			foreach int i in 0 .. 15 do
				pps_sl[pps_id][0][matrixId][i] := 16;
			end
			pps_sl_dc[pps_id][0][matrixId] := 16; // default for 16x16
			pps_sl_dc[pps_id][1][matrixId] := 16; // default for 32x32
		end
		foreach int i in 0 .. 63 do
			pps_sl[pps_id][1][0][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][1][1][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][1][2][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][1][3][i] := default_scaling_list_inter[i];
			pps_sl[pps_id][1][4][i] := default_scaling_list_inter[i];
			pps_sl[pps_id][1][5][i] := default_scaling_list_inter[i];
			pps_sl[pps_id][2][0][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][2][1][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][2][2][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][2][3][i] := default_scaling_list_inter[i];
			pps_sl[pps_id][2][4][i] := default_scaling_list_inter[i];
			pps_sl[pps_id][2][5][i] := default_scaling_list_inter[i];
			pps_sl[pps_id][3][0][i] := default_scaling_list_intra[i];
			pps_sl[pps_id][3][1][i] := default_scaling_list_inter[i];
		end
		se_idx := 51;
	end

	read_PPS_Header.se_idx_51_loopSize_id : action ==>
	guard
		se_idx = 51 and isFifoFull(fifo) , pps_size_id < 4
	do
		if pps_size_id = 3 then pps_size_id_matrixCase := 2; else pps_size_id_matrixCase := 6; end
		se_idx := 53;
	end

	read_PPS_Header.se_idx_53_loopMatrix_id: action ==>
	guard
		se_idx = 53 and isFifoFull(fifo) , pps_matrix_id < pps_size_id_matrixCase
	var
		uint(size=32) res[1],
		int delta,
		int size_id_memcpyCase,
		uint(size= 8) pps_scaling_list_pred_mode_flag[4][6],
		uint(size= 32) pps_scaling_list_dc_coef[2][6]
	do
		vld_u_name(  1, fifo, res, "scaling_list_pred_mode_flag             ");
		pps_scaling_list_pred_mode_flag[pps_size_id][pps_matrix_id] := res[0];
		if pps_scaling_list_pred_mode_flag[pps_size_id][pps_matrix_id] = 0 then
			vld_ue_name(    fifo, res, "delta                                   ");
				delta := res[0]; // Only need to handle non-zero delta. Zero means default, which should already be in the arrays.
				if delta != 0 then // Copy from previous array.
				if (pps_matrix_id - delta < 0) then
					println("Invalid delta in scaling list data");
				end
					if pps_size_id > 0 then
						size_id_memcpyCase := 64;
					else
						size_id_memcpyCase := 16;
					end
				foreach int k in 0 .. size_id_memcpyCase do
						pps_sl[pps_id][pps_size_id][pps_matrix_id][k] :=
						pps_sl[pps_id][pps_size_id][pps_matrix_id - delta][k];
				end
				if (pps_size_id > 1) then
						pps_sl_dc[pps_id][pps_size_id - 2][pps_matrix_id] :=
						pps_sl_dc[pps_id][pps_size_id - 2][pps_matrix_id - delta];
				end
			end
			pps_matrix_id := pps_matrix_id + 1;
		else
			pps_next_coef := 8;
			pps_coef_num := min(64, (1  <<  (4 + (pps_size_id  <<  1))));
			if (pps_size_id > 1) then
				vld_se_name(    fifo, res, "scaling_list_dc_coef                    ");
				pps_scaling_list_dc_coef[pps_size_id - 2][pps_matrix_id] := res[0] + 8;
					pps_next_coef := pps_scaling_list_dc_coef[pps_size_id -
					2][pps_matrix_id];
				pps_sl_dc[pps_id][pps_size_id - 2][pps_matrix_id] := pps_next_coef;
			end
			se_idx := 54;
			cnt_i := 0;
		end
	end

	read_PPS_Header.se_idx_54_loopNumCoef : action ==>
	guard
		se_idx = 54 and isFifoFull(fifo), cnt_i < pps_coef_num
	var
		uint(size=32) res[1]
	do
		if (pps_size_id = 0) then
			pps_pos := 4 * hevc_diag_scan4x4_y[cnt_i] + hevc_diag_scan4x4_x[cnt_i];
		else
			pps_pos := 8 * hevc_diag_scan8x8_y[cnt_i] + hevc_diag_scan8x8_x[cnt_i];
		end
		vld_se_name(    fifo, res, "scaling_list_delta_coef                 ");
		pps_scaling_list_delta_coef := res[0];
		pps_next_coef := (pps_next_coef + pps_scaling_list_delta_coef + 256) & 255;
		pps_sl[pps_id][pps_size_id][pps_matrix_id][pps_pos] := pps_next_coef;
		cnt_i := cnt_i + 1;
	end

	read_PPS_Header.se_idx_54_loopNumCoefEnd : action ==>
	guard
		se_idx = 54 and isFifoFull(fifo), cnt_i = pps_coef_num
	do
		cnt_i := 0;
		pps_matrix_id := pps_matrix_id + 1;
		se_idx := 53;
	end


	read_PPS_Header.se_idx_53_loopMatrix_id_End : action ==>
	guard
		se_idx = 53 and isFifoFull(fifo) , pps_matrix_id = pps_size_id_matrixCase
	do
		pps_size_id := pps_size_id + 1;
		pps_matrix_id := 0;
		se_idx := 51;
	end

	read_PPS_Header.se_idx_51_loopSize_id_End : action ==>
	guard
		se_idx = 51 and isFifoFull(fifo) , pps_size_id = 4
	do
		pps_size_id := 0;
		se_idx := 52;
	end

	/**************************************************************************
	 * read_PPS_Header_done
	 *************************************************************************/
	read_PPS_Header_done : action ==>
	guard
		se_idx = 6
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Slice HEADER                         *********************
	 **************************************************************************
	 *************************************************************************/

	/**************************************************************************
	 * read_SliceHeader.se_idx_1
	 *************************************************************************/
	uint(size= 8) Log2CtbSize;
	uint(size= 8) Log2MinCbSize;
	uint(size=16) PicWidthInCtbsY;
	uint(size=16) PicHeightInCtbsY;
	uint(size=16) PicSizeInCtbsY;
	uint(size= 1) slice_temporal_mvp_enable_flag;

	int(size=32) poc;
	uint(size= 3) slice_type;
	uint(size= 1) slice_sample_adaptive_offset_flag[4];

	procedure compute_POC(int pic_order_cnt_lsb)
	var
		 int iPOClsb = pic_order_cnt_lsb,
		 int iPrevPOC = poc,
		 int iMaxPOClsb := max_poc_lsb[sps_id],
		 int iPrevPOClsb,
		 int iPrevPOCmsb,
		 int iPOCmsb
	begin
		iPrevPOClsb := iPrevPOC mod iMaxPOClsb;
		iPrevPOCmsb := iPrevPOC-iPrevPOClsb;
		if( (iPOClsb < iPrevPOClsb) and ( (iPrevPOClsb - iPOClsb) >= (iMaxPOClsb / 2) ) ) then
			iPOCmsb := iPrevPOCmsb + iMaxPOClsb;
		else
			if( (iPOClsb > iPrevPOClsb)  and ( (iPOClsb - iPrevPOClsb) > (iMaxPOClsb / 2) ) ) then
				iPOCmsb := iPrevPOCmsb - iMaxPOClsb;
			else
				iPOCmsb := iPrevPOCmsb;
			end
		end
				if (nal_unit_type = NAL_BLA_W_LP   or
				nal_unit_type = NAL_BLA_W_RADL or
				nal_unit_type = NAL_BLA_N_LP)
		then
				iPOCmsb := 0;
		end

		poc:= iPOCmsb+iPOClsb;
	end

	uint(size= 1) first_slice_segment_in_pic_flag := 1;
	uint(size= 1) dependent_slice_segment_flag;
	uint(size=16) pictSize[2];
	uint(size=16) num_long_term_sps := 0;
	uint(size=16) num_long_term_pics := 0;
	uint(size= 8) poc_lsb_lt[32];
	uint(size= 8) UsedByCurrPicLt[32];
	uint(size= 8) DeltaPocMsbCycleLt[32];
	uint(size= 8) delta_poc_msb_present_flag[32];
	int pic_order_cnt_lsb;
	
	int slice_idx :=0;
	int idx := 0;
	
	

	read_SliceHeader.se_idx_1 : action ==> PartMode:[part_mode]

	guard
			se_idx = 1 and idx = 0 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 4) part_mode
	do

		Log2MinCbSize     := sps_log2_min_coding_block_size[sps_id] ;
		Log2CtbSize       := Log2MinCbSize + sps_log2_diff_max_min_coding_block_size[sps_id];
		PicWidthInCtbsY   := ( sps_pic_width_in_luma_samples[sps_id]  + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
		PicHeightInCtbsY  := ( sps_pic_height_in_luma_samples[sps_id] + ( 1 << Log2CtbSize )-1 ) >> Log2CtbSize;
		PicSizeInCtbsY    := PicWidthInCtbsY * PicHeightInCtbsY;

		TilesInfo := [TILE_SPLIT_ENABLE, TILE_INDEX];

		vld_u_name(  1, fifo, res, "first_slice_segment_in_pic_flag         ");
		first_slice_segment_in_pic_flag := res[0];

		if nal_unit_type >= 16 and nal_unit_type <= 23 then
			vld_u_name(  1, fifo, res, "no_output_of_prior_pics_flag            ");
		end
		vld_ue_name(    fifo, res, "slice_pic_parameter_set_id              ");
		pps_id := res[0];
		sps_id := pps_sps_id[pps_id];
		dependent_slice_segment_flag := 0;

		if first_slice_segment_in_pic_flag = 0 then
			if (pps_dependent_slice_segments_enabled_flag[pps_id] = 1) then
				vld_u_name(  1, fifo, res, "dependent_slice_segment_flag                    ");
				dependent_slice_segment_flag := res[0];
			end
			vld_u_name(log2((PicSizeInCtbsY-1)<<1) , fifo, res, "slice_segment_address                   ");
			if (dependent_slice_segment_flag = 0) then
				slice_idx := slice_idx + 1;
			end
		end

			pictSize[0] := sps_pic_width_in_luma_samples[sps_id];
			pictSize[1] := sps_pic_height_in_luma_samples[sps_id];

		if first_slice_segment_in_pic_flag = 1 then
			part_mode := PART_MODE_PICT;
		elsif dependent_slice_segment_flag = 0 then
			part_mode := PART_MODE_SLICE_INDEP;
		else
			part_mode := PART_MODE_SLICE_DEP;
		end
		if dependent_slice_segment_flag = 0 then
				se_idx := 200;
			else
				se_idx := 6;
			end
		end

		read_SliceHeader.se_idx_11 : action ==> LcuSizeMax:[Log2CtbSize], Poc:[poc], SliceType:[slice_type]
		guard
				se_idx = 200 and isFifoFull(fifo)
		var
			uint(size=32) res[1],
			uint(size= 8) numbits := 0,
			uint(size= 8) lt_idx_sps := 0,
			uint(size= 8) prevDeltaMSB := 0,
			uint(size=16) column_width[PICT_WIDTH / MIN_CTB_SIZE_Y]= [pps_column_width[pps_id][ i ] : for int i in 0 .. (PICT_WIDTH / MIN_CTB_SIZE_Y)-1],
			uint(size=16) row_height[PICT_HEIGHT / MIN_CTB_SIZE_Y]  = [pps_row_height[pps_id][ i ] : for int i in 0 .. (PICT_HEIGHT / MIN_CTB_SIZE_Y)-1],
			uint(size= 8) num_tile_columns_minus1           = pps_num_tile_columns_minus1[pps_id],
			uint(size= 8) num_tile_rows_minus1                      = pps_num_tile_rows_minus1[pps_id],
			uint(size= 1) uniform_spacing_flag                      = pps_uniform_spacing_flag[pps_id]
		do
			foreach int i in 0 .. pps_num_extra_slice_header_bits[pps_id] - 1 do
				vld_u_name(  1, fifo, res, "slice_reserved_undetermined_flag[i]     ");
			end
			vld_ue_name(    fifo, res, "slice_type                              ");
			slice_type := res[0];

			slice_temporal_mvp_enable_flag := 0;
			idx := 0;
			if(pps_output_flag_present_flag[pps_id] = 1) then
				vld_u_name(  1, fifo, res, "pic_output_flag                         ");
			end
			if sps_separate_colour_plane_flag[sps_id] = 1 then
				vld_u_name(  2, fifo, res, "colour_plane_id                         ");
			end

			if nal_unit_type = NAL_IDR_W_DLP or nal_unit_type = NAL_IDR_N_LP then
				poc := 0;
				//sps_num_short_term_ref_pic_sets[sps_id] := 0;
			else
				vld_u_name( sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4, fifo, res, "pic_order_cnt_lsb                       ");
				pic_order_cnt_lsb := res[0];
				//compute the number of POC
				compute_POC(res[0]);
			
				vld_u_name(  1, fifo, res, "short_term_ref_pic_set_sps_flag         ");
				if res[0] = 0 then
					parseShortTermRefPicSet(sps_id, sps_num_short_term_ref_pic_sets[sps_id], sps_num_short_term_ref_pic_sets[sps_id], fifo, pcRPS);
				else
					while ((1 << numbits) < sps_num_short_term_ref_pic_sets[sps_id]) do
						numbits := numbits + 1;
					end
					res[0] := 0;
					if (numbits > 0) then
						vld_u_name(   numbits, fifo, res, "short_term_ref_pic_set_idx              ");
					end
					pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]] := [pcRPS[sps_id][res[0]][i] : for int i in 0 .. PC_RPS_STRUCT_SIZE - 1];
				end
				num_long_term_sps := 0;
				num_long_term_pics := 0;

				if sps_long_term_ref_pics_present_flag[sps_id] = 1 then
					if sps_num_long_term_ref_pics_sps[sps_id] > 0 then
						vld_ue_name(    fifo, res, "num_long_term_sps                       ");
						num_long_term_sps := res[0];
					end
					vld_ue_name(    fifo, res, "num_long_term_pics                      ");
					num_long_term_pics := res[0];
//					numbits := 0;
//                    while (sps_num_long_term_ref_pics_sps[sps_id] > (1 << numbits)) do
//                        numbits := numbits + 1;
//                    end
					foreach int i in 0 .. num_long_term_sps + num_long_term_pics - 1 do
						if i < num_long_term_sps then
							if num_long_term_pics > 1 then
								vld_u_name(log2((PicSizeInCtbsY-1)<<1) , fifo, res, "lt_idx_sps                              ");
								lt_idx_sps := res[0];
							end
							poc_lsb_lt[i] := lt_ref_pic_poc_lsb_sps[lt_idx_sps];
							UsedByCurrPicLt[i] := used_by_curr_pic_lt_sps_flag[lt_idx_sps];
						else
							vld_u_name( sps_log2_max_pic_order_cnt_lsb_minus4[sps_id] + 4, fifo, res, "poc_lsb_lt                              ");
							poc_lsb_lt[i] := res[0];
							vld_u_name(  1, fifo, res, "used_by_curr_pic_lt_flag                ");
							UsedByCurrPicLt[i] :=  res[0];
						end
						vld_u_name(  1, fifo, res, "delta_poc_msb_present_flag              ");
						delta_poc_msb_present_flag[i] := res[0];
						if res[0] = 1 then
							if( i = 0 or i = num_long_term_sps ) then
								vld_ue_name(    fifo, res, "delta_poc_msb_cycle_lt_minus1                ");
								DeltaPocMsbCycleLt[i] := res[0];
							else
								vld_ue_name(    fifo, res, "delta_poc_msb_cycle_lt_minus1                ");
								DeltaPocMsbCycleLt[i] := res[0] + prevDeltaMSB;
							end
							prevDeltaMSB := DeltaPocMsbCycleLt[i];
						end
					end
				end
				if sps_temporal_mvp_enable_flag[sps_id] = 1 then
					vld_u_name(  1, fifo, res, "slice_temporal_mvp_enable_flag          ");
					slice_temporal_mvp_enable_flag := res[0];
				else
					slice_temporal_mvp_enable_flag := 0;
				end
			end

			if (temporal_id = 0 and nal_unit_type != NAL_TRAIL_N and
				nal_unit_type != NAL_TSA_N   and
				nal_unit_type != NAL_STSA_N  and
				nal_unit_type != NAL_RADL_N  and
				nal_unit_type != NAL_RADL_R  and
				nal_unit_type != NAL_RASL_N  and
				nal_unit_type != NAL_RASL_R) then

//	            pocTid0 := poc;
			end

			if( sps_sample_adaptive_offset_enabled_flag[sps_id] = 1) then
				vld_u_name(  1, fifo, res, "slice_sao_luma_flag                     ");
				slice_sample_adaptive_offset_flag[0] := res[0];
				vld_u_name(  1, fifo, res, "slice_sao_chroma_flag                   ");
				slice_sample_adaptive_offset_flag[1] := res[0];
				slice_sample_adaptive_offset_flag[2] := res[0];
						else
								slice_sample_adaptive_offset_flag[0] := 0;
						slice_sample_adaptive_offset_flag[1] := 0;
						slice_sample_adaptive_offset_flag[2] := 0;
			end



	//	            if (first_slice_segment_in_pic_flag = 1) then
	//	                    sao := slice_sample_adaptive_offset_flag[0] + (slice_sample_adaptive_offset_flag[1]<<1);
	//	                    isPicSlcLcu := 0;
	//	            else
	//	                    sao := slice_sample_adaptive_offset_flag[0] + slice_sample_adaptive_offset_flag[1];
	//	                    isPicSlcLcu := 2 ;
	//	            end

		//////////////////////////////////////////////////////////////////////////// copied from line 2412
		if num_tile_columns_minus1 >= (PICT_WIDTH / MIN_CTB_SIZE_Y) then
			println("Error read_SliceData.init : ColumnWidth : "+num_tile_columns_minus1+" >= "+(PICT_WIDTH / MIN_CTB_SIZE_Y));
		end
		if uniform_spacing_flag = 1 then
			foreach int i in 0 .. num_tile_columns_minus1 do
				colWidth[ i ] := ((i + 1)*PicWidthInCtbsY) / (num_tile_columns_minus1+1) - (i*PicWidthInCtbsY) / (num_tile_columns_minus1+1);
				colTileInPix[ i + 1 ] :=   (colWidth[ i ] << Log2CtbSize) + colTileInPix[ i ];
				if i = num_tile_columns_minus1 then
					colTileInPix[ i + 1 ] := pictSize [0];
				end
			end
		else
			colWidth[ num_tile_columns_minus1 ] := PicWidthInCtbsY;
			foreach int i in 0 .. num_tile_columns_minus1 - 1 do
				colWidth[ i ] := column_width[ i ] ;
				colWidth[ num_tile_columns_minus1 ] := colWidth[ num_tile_columns_minus1 ] - colWidth[ i ];
				colTileInPix[ i + 1 ] :=   (colWidth[ i ] << Log2CtbSize) + colTileInPix[ i ];
				if i = num_tile_columns_minus1 - 1 then
					colTileInPix[ i + 2 ] := pictSize [0];
				end
			end
		end

		if num_tile_rows_minus1 >= (PICT_HEIGHT / MIN_CTB_SIZE_Y) then
			println("Error read_SliceData.init : RowHeight : "+num_tile_rows_minus1+" >= "+(PICT_HEIGHT / MIN_CTB_SIZE_Y));
		end
		if uniform_spacing_flag = 1 then
			foreach int i in 0 .. num_tile_rows_minus1 do
				rowHeight[ i ] := ((i+1)*PicHeightInCtbsY) / (num_tile_rows_minus1+1) - (i*PicHeightInCtbsY) / (num_tile_rows_minus1+1);
				rowTileInPix[ i + 1 ] :=   (rowHeight[ i ] << Log2CtbSize) + rowTileInPix[ i ];
				if i = num_tile_rows_minus1 then
					rowTileInPix[ i + 1 ] := pictSize [1];
				end
			end
		else
			rowHeight[ num_tile_rows_minus1 ] := PicHeightInCtbsY;
			foreach int i in 0 .. num_tile_rows_minus1 - 1 do
				rowHeight[ i ] := row_height[ i ];
				rowHeight[ num_tile_rows_minus1 ] := rowHeight[ num_tile_columns_minus1 ] - rowHeight[ i ];
				rowTileInPix[ i + 1 ] :=   (rowHeight[ i ] << Log2CtbSize) + rowTileInPix[ i ];
				if i = num_tile_rows_minus1 - 1 then
					rowTileInPix[ i + 2 ] := pictSize [1];
				end
			end
		end
			se_idx := 2;
	end


	/**************************************************************************
	 * read_SliceHeader.se_idx_2
	 *************************************************************************/
	uint(size= 8) num_ref_idx_l0_active;
	uint(size= 8) num_ref_idx_l1_active;
	uint(size= 8) ref_pic_list_modification_flag_lx[2] := [0,0];
	uint(size=4) list_entry_lx [2][32];

	read_SliceHeader.se_idx_2 : action ==>
	guard
		se_idx = 2 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		int NumPocTotalCurr := 0
	do
		num_ref_idx_l0_active    := 0;
		num_ref_idx_l1_active    := 0;
		if slice_type = P_SLICE or slice_type = B_SLICE then
			num_ref_idx_l0_active := pps_num_ref_idx_l0_default_active_minus1[pps_id] + 1;
			if slice_type = B_SLICE then
				num_ref_idx_l1_active := pps_num_ref_idx_l1_default_active_minus1[pps_id] + 1;
			end
			vld_u_name(  1, fifo, res, "num_ref_idx_active_override_flag        ");
			if res[0] = 1 then
				vld_ue_name(    fifo, res, "num_ref_idx_l0_active_minus1            ");
				num_ref_idx_l0_active := res[0] + 1;
				if slice_type = B_SLICE then
					vld_ue_name(    fifo, res, "num_ref_idx_l1_active_minus1            ");
					num_ref_idx_l1_active := res[0] + 1;
				end
			end

			ref_pic_list_modification_flag_lx[0] := 0;
			ref_pic_list_modification_flag_lx[1] := 0;

			foreach int i in 0 .. pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS]-1 do
				if (pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][USED+i] = 1) then
					NumPocTotalCurr := NumPocTotalCurr + 1;
				end
			end

			foreach int i in pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_NEGATIVE_PICS] .. pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][NUM_PICS]-1 do
				if (pcRPS[sps_id][sps_num_short_term_ref_pic_sets[sps_id]][USED+i] = 1) then
					NumPocTotalCurr := NumPocTotalCurr + 1;
				end
			end

			foreach int i in 0 .. num_long_term_sps + num_long_term_pics - 1 do
				if ( UsedByCurrPicLt[i] = 1) then
					NumPocTotalCurr := NumPocTotalCurr + 1;
				end
			end

			if pps_lists_modification_present_flag[pps_id] = 1 and NumPocTotalCurr > 1 then
				vld_u_name(  1, fifo, res, "ref_pic_list_modification_flag_l0       ");
				ref_pic_list_modification_flag_lx[0] := res[0];
				if ref_pic_list_modification_flag_lx[0] = 1 then
					foreach int i in 0 .. num_ref_idx_l0_active - 1 do
						vld_u_name(log2((NumPocTotalCurr-1)<<1) , fifo, res, "list_entry_lx                           ");
						list_entry_lx[0][i] := res[0];
					end
				end

				if slice_type = B_SLICE then
					vld_u_name(  1, fifo, res, "ref_pic_list_modification_flag_l1       ");
					ref_pic_list_modification_flag_lx[1] := res[0];
					if ref_pic_list_modification_flag_lx[1] = 1 then
						foreach int i in 0 .. num_ref_idx_l1_active - 1 do
							vld_u_name(log2((NumPocTotalCurr-1)<<1) , fifo, res, "list_entry_lx                           ");
							list_entry_lx[1][i] := res[0];
						end
					end
				end
			end
			if slice_type = B_SLICE then
				vld_u_name(  1, fifo, res, "mvd_l1_zero_flag                        ");
			end
		end
		se_idx := 10;
	end
	/**************************************************************************
	 * read_SliceHeader.sendRefPOC
	 *************************************************************************/
	int(size=16)  pocTables[5][NB_MAX_PICS];
	int numPic[5];
	uint(size= 8) idxNumPic;
	uint(size= 8) idxRefPoc;

	procedure setRefTables(int sps_id, int idx, int(size=8) pc_rps[NB_MAX_SPS][NB_MAX_PICS+1][PC_RPS_STRUCT_SIZE], int poc)
	var
		uint j := 0,
		uint k := 0,
		int pocLt := poc_lsb_lt[0]
	begin
		foreach int i in 0 .. pc_rps[sps_id][idx][NUM_NEGATIVE_PICS]-1
		do
			if(pc_rps[sps_id][idx][USED+i]=1) then
						pocTables[ST_CURR_BEF][j] := poc +
						pc_rps[sps_id][idx][DELTAPOC + i];
				j := j + 1;
			else
				pocTables[ST_FOLL][k] := poc + pc_rps[sps_id][idx][DELTAPOC+i];
				k := k + 1;
			end
		end
		numPic[ST_CURR_BEF] := j;
		j:=0;
		foreach int i in
				pc_rps[sps_id][idx][NUM_NEGATIVE_PICS] ..
				pc_rps[sps_id][idx][NUM_PICS] - 1 do
			if(pc_rps[sps_id][idx][USED+i]=1) then
						pocTables[ST_CURR_AFT][j] := poc +
						pc_rps[sps_id][idx][DELTAPOC + i];
				j := j + 1;
			else
				pocTables[ST_FOLL][k] := poc + pc_rps[sps_id][idx][DELTAPOC+i];
				k := k + 1;
			end
		end
		numPic[ST_CURR_AFT] := j;
		numPic[ST_FOLL] := k;
		j := 0;
		k := 0;
		foreach int i in 0 .. (num_long_term_sps +
				num_long_term_pics) - 1 do
			pocLt := poc_lsb_lt[i];
			if delta_poc_msb_present_flag[i] = 1 then
				pocLt := pocLt + poc - DeltaPocMsbCycleLt[i] * max_poc_lsb[sps_id] - pic_order_cnt_lsb;
			end
			if UsedByCurrPicLt[i] = 1 then
				pocTables[LT_CURR][j] := pocLt;
				j := j + 1;
			else
				pocTables[LT_FOLL][k] := pocLt;
				k := k + 1;
			end
		end
		numPic[LT_CURR] := j;
		numPic[LT_FOLL] := k;
	end

	read_SliceHeader.sendRefPOC.init : action ==> NumRefIdxLxActive:[num_ref_idx_l0_active, num_ref_idx_l1_active]
	guard
		se_idx = 10
	do
		setRefTables(sps_id, sps_num_short_term_ref_pic_sets[sps_id], pcRPS, poc);
		idxNumPic := 0;
		se_idx    := 101;
	end

	read_SliceHeader.sendListEntryL0Flag : action ==> RefPicListModif:[ref_pic_list_modification_flag_lx[0]]
	guard
		se_idx = 101
	do
		if ref_pic_list_modification_flag_lx[0] = 0 then
			se_idx := 201;
		else
			se_idx := 102;
		end
	end

	read_SliceHeader.sendListEntryL0Loop : action ==> RefPicListModif:[list_entry_lx[0][cnt_i - 1]]
	guard
		se_idx = 102,
		cnt_i < num_ref_idx_l0_active
	do
		cnt_i := cnt_i + 1;
	end

	read_SliceHeader.sendListEntryL0End : action ==>
	guard
		se_idx = 102,
		cnt_i = num_ref_idx_l0_active
	do
		cnt_i := 0;
		se_idx := 201;

	end

	read_SliceHeader.sendListEntryL1Flag : action ==> RefPicListModif:[ref_pic_list_modification_flag_lx[1]]
	guard
		se_idx = 201
	do
		if ref_pic_list_modification_flag_lx[1] = 0 then
			se_idx := 11;
		else
			se_idx := 202;
		end
	end

	read_SliceHeader.sendListEntryL1Loop : action ==> RefPicListModif:[list_entry_lx[1][cnt_i - 1]]
	guard
		se_idx = 202,
		cnt_i < num_ref_idx_l1_active
	do
		cnt_i := cnt_i + 1;
	end

	read_SliceHeader.sendListEntryL1End : action ==>
	guard
		se_idx = 202,
		cnt_i = num_ref_idx_l1_active
	do
		cnt_i := 0;
		se_idx    := 11;
	end
	read_SliceHeader.sendRefPOC.sendSize : action ==> RefPoc:[refPocSize]
	guard
		se_idx = 11
	var
				int(size=16) refPocSize = numPic[idxNumPic]
	do
		if numPic[idxNumPic] = 0 then
			idxNumPic := idxNumPic + 1;
			if idxNumPic = 5 then
				se_idx := 3;
			end
		else
			idxRefPoc := 0;
			se_idx    := 12;
		end
	end
	read_SliceHeader.sendRefPOC.sendRefPoc : action ==> RefPoc:[refPoc]
	guard
		se_idx = 12
	var
				int(size=16) refPoc = pocTables[idxNumPic][idxRefPoc]
	do
		idxRefPoc := idxRefPoc + 1;
		if idxRefPoc = numPic[idxNumPic] then
			idxNumPic := idxNumPic + 1;
			if idxNumPic = 5 then
				se_idx := 3;
			else
				se_idx := 11;
			end
		end
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_3
	 *************************************************************************/
	 int(size= 8) slice_cb_qp_offset;
	 int(size= 8) slice_cr_qp_offset;

	read_SliceHeader.se_idx_3 : action ==> WeightedPredLuma:[weighted_pred_flag], WeightedPredChroma:[weighted_pred_flag]
	guard
		se_idx = 3 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 2) weighted_pred_flag := 0,
				uint(size= 1) collocated_from_l0_flag := 1
	do
		se_idx := 5;

		if slice_type = P_SLICE or slice_type = B_SLICE then
			if pps_cabac_init_present_flag[pps_id] = 1	then
				vld_u_name(  1, fifo, res, "cabac_init_flag                         ");
			end
			if slice_temporal_mvp_enable_flag = 1 then
				res[0] := 1;
				if( slice_type = B_SLICE ) then
					vld_u_name(  1, fifo, res, "collocated_from_l0_flag                 ");
					collocated_from_l0_flag := res[0];
				end
				if ( collocated_from_l0_flag = 1 and num_ref_idx_l0_active > 1 ) or ( collocated_from_l0_flag = 0 and num_ref_idx_l1_active > 1 ) then
					vld_ue_name(    fifo, res, "collocated_ref_idx                      ");
				end
			end
			if pps_weighted_pred_flag[pps_id] = 1 or pps_weighted_bipred_flag[pps_id] = 1 then
				weighted_pred_flag := 1;
			end

			if weighted_pred_flag != 0 then
				se_idx := 4;
			end
		end
	end
	/**************************************************************************
	 * read_SliceHeader.se_idx_4
	 *************************************************************************/
	uint(size= 1) luma_weight_l0_flag[16];
	uint(size= 1) chroma_weight_l0_flag[16];
	 int(size= 8) delta_luma_weight_l0;
	 int(size= 8) luma_offset_l0;
	 int(size= 8) delta_chroma_weight_l00;
	 int(size= 8) delta_chroma_weight_l01;
	 int(size= 10) delta_chroma_offset_l00;
	 int(size= 10) delta_chroma_offset_l01;

	uint(size= 1) luma_weight_l1_flag[16];
	uint(size= 1) chroma_weight_l1_flag[16];
	 int(size= 8) delta_luma_weight_l1;
	 int(size= 8) luma_offset_l1;
	 int(size= 8) delta_chroma_weight_l10;
	 int(size= 8) delta_chroma_weight_l11;
	 int(size= 10) delta_chroma_offset_l10;
	 int(size= 10) delta_chroma_offset_l11;

	read_SliceHeader.se_idx_40 : action ==> WeightedPredLuma:[luma_log2_weight_denom, delta_chroma_log2_weight_denom],
											 WeightedPredChroma:[luma_log2_weight_denom, delta_chroma_log2_weight_denom]
	guard
		se_idx = 4 and isFifoFull(fifo),
		slice_type = P_SLICE or slice_type = B_SLICE,
		(pps_weighted_pred_flag[pps_id] = 1 and slice_type = P_SLICE) or ( pps_weighted_bipred_flag[pps_id] = 1 and slice_type = B_SLICE )
	var
		uint(size=32) res[1],
		uint(size= 3) luma_log2_weight_denom := 0,
		 int(size= 4) delta_chroma_log2_weight_denom :=0
	do
		vld_ue_name(    fifo, res, "luma_log2_weight_denom                  ");
		luma_log2_weight_denom := res[0];
		if sps_chroma_format_idc[sps_id] != 0 then
			vld_se_name(    fifo, res, "delta_chroma_log2_weight_denom          ");
			delta_chroma_log2_weight_denom := res[0];
		end
		se_idx := 41;
	end

	read_SliceHeader.se_idx_41 : action ==> WeightedPredLuma:[luma_weight_l0_flag[cnt_i - 1]]
	guard
		se_idx = 41 and isFifoFull(fifo),
		cnt_i <num_ref_idx_l0_active
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "luma_weight_lX_flag                     ");
		luma_weight_l0_flag[cnt_i] := res[0];
		cnt_i := cnt_i +1;
	end

	read_SliceHeader.se_idx_42 : action ==>
	guard
		se_idx = 41 and isFifoFull(fifo),
		cnt_i = num_ref_idx_l0_active
	do
		cnt_i := 0;
		se_idx := 43;
	end

	read_SliceHeader.se_idx_43 : action ==> WeightedPredChroma:[chroma_weight_l0_flag[cnt_i - 1]]
	guard
		se_idx = 43 and isFifoFull(fifo),
		sps_chroma_format_idc[sps_id] = 1,
		cnt_i < num_ref_idx_l0_active
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "chroma_weight_lX_flag                   ");
		chroma_weight_l0_flag[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end

	read_SliceHeader.se_idx_44 : action ==>
	guard
		se_idx = 43 and isFifoFull(fifo),
		cnt_i = num_ref_idx_l0_active
	do
		cnt_i := 0;
		se_idx := 45;
	end


	read_SliceHeader.se_idx_45_skip_loop : action ==>
	guard
		se_idx = 45 and isFifoFull(fifo),
		luma_weight_l0_flag[cnt_i] = 0,
		chroma_weight_l0_flag[cnt_i] = 0,
		cnt_i < num_ref_idx_l0_active
	do
		cnt_i := cnt_i + 1;
	end

	read_SliceHeader.se_idx_45_skip_loop_done : action ==>
	guard
		se_idx = 45 and isFifoFull(fifo),
		cnt_i = num_ref_idx_l0_active,
		slice_type = B_SLICE
	do
		cnt_i := 0;
		se_idx := 48;
	end

	read_SliceHeader.se_idx_45_skip_all : action ==>
	guard
		se_idx = 45 and isFifoFull(fifo),
		cnt_i = num_ref_idx_l0_active,
		slice_type != B_SLICE
	do
		cnt_i := 0;
		se_idx := 5;
	end

	read_SliceHeader.se_idx_45 : action ==> WeightedPredLuma:[delta_luma_weight_l0, luma_offset_l0]
	guard
		se_idx = 45 and isFifoFull(fifo),
		luma_weight_l0_flag[cnt_i] = 1,
		cnt_i < num_ref_idx_l0_active
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_luma_weight_lX                    ");
		delta_luma_weight_l0 := res[0];
		vld_se_name(    fifo, res, "luma_offset_lX                          ");
		luma_offset_l0 := res[0];
		se_idx := 46;
	end

	read_SliceHeader.se_idx_45_skip : action ==>
	guard
		se_idx = 45 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l0_active,
		luma_weight_l0_flag[cnt_i] = 0
	do
		se_idx := 46;
	end

	read_SliceHeader.se_idx_46_skip : action ==>
	guard
		se_idx = 46 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l0_active,
		chroma_weight_l0_flag[cnt_i] = 0
	do
		cnt_i := cnt_i + 1;
		se_idx := 45;
	end

	read_SliceHeader.se_idx_46 : action ==> WeightedPredChroma:[delta_chroma_weight_l00]
	guard
		se_idx = 46 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l0_active,
		chroma_weight_l0_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_chroma_weight_lX                  ");
		delta_chroma_weight_l00 := res[0];
		se_idx := 47;
	end

	read_SliceHeader.se_idx_47 : action ==> WeightedPredChroma:[delta_chroma_offset_l00, delta_chroma_weight_l01, delta_chroma_offset_l01]
	guard
		se_idx = 47 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l0_active,
		chroma_weight_l0_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_chroma_offset_lX                  ");
		delta_chroma_offset_l00 := res[0];
		vld_se_name(    fifo, res, "delta_chroma_weight_lX                  ");
		delta_chroma_weight_l01 := res[0];
		vld_se_name(    fifo, res, "delta_chroma_offset_lX                  ");
		delta_chroma_offset_l01 := res[0];
		cnt_i := cnt_i + 1;
		se_idx := 45;
	end



	read_SliceHeader.se_idx_48 : action ==>  WeightedPredLuma:[luma_weight_l1_flag[cnt_i-1]]
	guard
		se_idx = 48 and isFifoFull(fifo),
		slice_type = B_SLICE,
		cnt_i < num_ref_idx_l1_active
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "luma_weight_lX_flag                     ");
		luma_weight_l1_flag[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end

	read_SliceHeader.se_idx_49 : action ==>
	guard
		se_idx = 48 and isFifoFull(fifo),
		slice_type = B_SLICE,
		cnt_i = num_ref_idx_l1_active
	do
		cnt_i := 0;
		se_idx := 50;
	end

	read_SliceHeader.se_idx_50_skip : action ==>
	guard
		se_idx = 50 and isFifoFull(fifo),
		sps_chroma_format_idc[sps_id] = 0
	do
		cnt_i := 0;
		se_idx := 52;
	end

	read_SliceHeader.se_idx_50 : action ==>  WeightedPredChroma:[chroma_weight_l1_flag[cnt_i - 1]]
	guard
		se_idx = 50 and isFifoFull(fifo),
		sps_chroma_format_idc[sps_id] != 0,
		cnt_i < num_ref_idx_l1_active
	var
		uint(size=32) res[1]
	do
		vld_u_name(  1, fifo, res, "chroma_weight_lX_flag                   ");
		chroma_weight_l1_flag[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end

	read_SliceHeader.se_idx_51 : action ==>
	guard
		se_idx = 50 and isFifoFull(fifo),
		sps_chroma_format_idc[sps_id] != 0,
		cnt_i = num_ref_idx_l1_active
	do
		cnt_i := 0;
		se_idx := 52;
	end

	read_SliceHeader.se_idx_52_skip_loop : action ==>
	guard
		se_idx = 52 and isFifoFull(fifo),
		luma_weight_l1_flag[cnt_i] = 0,
		chroma_weight_l1_flag[cnt_i] = 0,
		cnt_i < num_ref_idx_l1_active
	do
		cnt_i := cnt_i + 1;
	end

	read_SliceHeader.se_idx_52_skip_loop_done : action ==>
	guard
		se_idx = 52 and isFifoFull(fifo),
		cnt_i = num_ref_idx_l1_active
	do
		cnt_i := 0;
		se_idx := 5;
	end

	read_SliceHeader.se_idx_52 : action ==> WeightedPredLuma:[delta_luma_weight_l1, luma_offset_l1]
	guard
		se_idx = 52 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		luma_weight_l1_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_luma_weight_lX                    ");
		delta_luma_weight_l1 := res[0];
		vld_se_name(    fifo, res, "luma_offset_lX                          ");
		luma_offset_l1 := res[0];
		se_idx := 53;
	end

	read_SliceHeader.se_idx_52_skip : action ==>
	guard
		se_idx = 52 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		luma_weight_l1_flag[cnt_i] = 0
	do
		se_idx := 53;
	end

	read_SliceHeader.se_idx_53_skip : action ==>
	guard
		se_idx = 53 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		chroma_weight_l1_flag[cnt_i] = 0
	do
		cnt_i := cnt_i + 1;
		se_idx := 52;
	end

	read_SliceHeader.se_idx_53 : action ==> WeightedPredChroma:[delta_chroma_weight_l10]
	guard
		se_idx = 53 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		chroma_weight_l1_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_chroma_weight_lX                  ");
		delta_chroma_weight_l10 := res[0];
		se_idx := 54;
	end

	read_SliceHeader.se_idx_54 : action ==> WeightedPredChroma:[delta_chroma_offset_l10,delta_chroma_weight_l11,delta_chroma_offset_l11]
	guard
		se_idx = 54 and isFifoFull(fifo),
		cnt_i < num_ref_idx_l1_active,
		chroma_weight_l1_flag[cnt_i] = 1
	var
		uint(size=32) res[1]
	do
		vld_se_name(    fifo, res, "delta_chroma_offset_lX                  ");
		delta_chroma_offset_l10 := res[0];
		vld_se_name(    fifo, res, "delta_chroma_weight_lX                  ");
		delta_chroma_weight_l11 := res[0];
		vld_se_name(    fifo, res, "delta_chroma_offset_lX                  ");
		delta_chroma_offset_l11 := res[0];
		cnt_i := cnt_i + 1;
		se_idx := 52;
	end

	/**************************************************************************
	 * read_SliceHeader.se_idx_5
	 *************************************************************************/
	read_SliceHeader.se_idx_5 : action ==> DBFDisable:[slice_disable_deblocking_filter_flag !=0],
		DbfSe:[betaOff, tcOff, pps_cb_qp_offset[pps_id] + slice_cb_qp_offset, pps_cr_qp_offset[pps_id] + slice_cr_qp_offset]
	guard
		se_idx = 5 and isFifoFull(fifo)
	var
		uint(size=32) res[1],
		uint(size= 1) slice_disable_deblocking_filter_flag := pps_disable_deblocking_filter_flag[pps_id],
		int(size=8) betaOff := pps_beta_offset[pps_id],
		int(size=8) tcOff := pps_tc_offset[pps_id]
	do
		if slice_type = P_SLICE or slice_type = B_SLICE then
			vld_ue_name(    fifo, res, "five_minus_max_num_merge_cand           ");
		end
		vld_se_name(    fifo, res, "slice_qp_delta                          ");
		slice_cb_qp_offset := 0;
		slice_cr_qp_offset := 0;
				if pps_cu_qp_delta_enabled_flag[pps_id] = 0 then
				end
		if pps_slice_chroma_qp_offsets_present_flag[pps_id] = 1 then
			vld_se_name(    fifo, res, "slice_cb_qp_offset                      ");
			slice_cb_qp_offset := res[0];
			vld_se_name(    fifo, res, "slice_cr_qp_offset                      ");
			slice_cr_qp_offset := res[0];
		end
		if(pps_deblocking_filter_control_present_flag[pps_id] = 1) then
		   res[0] := 0;
			if(deblocking_filter_override_enabled_flag[pps_id] = 1) then
						vld_u_name(1, fifo, res,
						"deblocking_filter_override_flag         ");
			end
			if res[0] = 1 then
						vld_u_name(1, fifo, res,
						"slice_disable_deblocking_filter_flag    ");
				slice_disable_deblocking_filter_flag := res[0];
				if( slice_disable_deblocking_filter_flag = 0) then
							vld_se_name(fifo, res,
							"beta_offset_div2                        ");
					betaOff := res[0] << 1;
							vld_se_name(fifo, res,
							"tc_offset_div2                          ");
					tcOff := res[0] << 1;
				end
			end
		end
				if (pps_loop_filter_across_slice_enabled_flag[sps_id] = 1 and
				(slice_sample_adaptive_offset_flag[0] = 1 or
				slice_sample_adaptive_offset_flag[1] = 1 or
				slice_disable_deblocking_filter_flag = 0)) then
					vld_u_name(1, fifo, res,
					"slice_loop_filter_across_slices_enabled_flag");
		end
		se_idx := se_idx + 1;
	end
	/**************************************************************************
	 * read_SliceHeader_done
	 *************************************************************************/
//         procedure initWpScaling()
//         begin
//                foreach uint(size=8) e in 0 .. 1 do
//                        foreach uint(size=8) i in 0 .. MAX_NUM_REF-1 do
//                                foreach uint(size=8) yuv in 0 .. 2 do
//                                        if wp[e][i][yuv][WP_PRESENT_FLAG] = 1 then
//                                                wp[e][i][yuv][WP_I_WEIGHT] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]);
//                                                wp[e][i][yuv][WP_I_OFFSET] := 0;
//                                        end
//                                        wp[e][i][yuv][WP_W]     := wp[e][i][yuv][WP_I_WEIGHT];
//                                        wp[e][i][yuv][WP_O]     := wp[e][i][yuv][WP_I_OFFSET] * (1);
//                                        wp[e][i][yuv][WP_SHIFT] := wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM];
//                                        if wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM] >= 1 then
//                                                wp[e][i][yuv][WP_ROUND] := (1 << wp[e][i][yuv][WP_LOG2_WEIGHT_DENOM]) - 1;
//                                        else
//                                                wp[e][i][yuv][WP_ROUND] := 0;
//                                        end
//                                end
//                        end
//                end
//        end
	uint(size=16) num_entry_point_offsets := 0;
	uint(size=16) offset_len;
	uint(size= 8) slice_segment_header_extension_length;

		read_SliceHeader.se_idx_6 : action ==>
	guard
		se_idx = 6 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		se_idx := 8;
		if pps_tiles_enabled_flag[pps_id] = 1 or
		pps_entropy_coding_sync_enabled_flag[pps_id] = 1 then
			vld_ue_name(fifo, res, "num_entry_point_offsets                 ");
			num_entry_point_offsets := res[0];
			if num_entry_point_offsets > NUM_ENTRY_MAX then
				println("ERROR: fix NUM_ENTRY_MAX");
			end
			if num_entry_point_offsets > 0 then
				vld_ue_name(fifo, res, "offset_len_minus1                       ");
				offset_len := res[0] + 1;
				se_idx := 7;
			end
		end
		
	end

	read_SliceHeader.se_idx_7_loop : action ==>
	guard
		se_idx = 7 and isFifoFull(fifo), cnt_i < num_entry_point_offsets
	var
		uint(size=32) res[1]
	do
		if offset_len > 32 then
			println("ERROR with vld_ue : check offset_len size");
		end
		vld_u_name(  offset_len, fifo, res, "entry_point_offset                      ");
		entryOffsetsTab[cnt_i] := res[0];
		cnt_i := cnt_i + 1;
	end

	read_SliceHeader.se_idx_7_endLoop : action ==>
	guard
		se_idx = 7 and isFifoFull(fifo), cnt_i = num_entry_point_offsets
	do
		cnt_i := 0;
		se_idx := 8;
	end

	read_SliceHeader.se_idx_8 : action ==>
	guard
		se_idx = 8 and isFifoFull(fifo)
	var
		uint(size=32) res[1]
	do
		se_idx := 100;
		if pps_slice_segment_header_extension_present_flag[pps_id] = 1 then
			vld_ue_name(    fifo, res, "slice_segment_header_extension_length   ");
			slice_segment_header_extension_length := res[0];
			se_idx := 9;
		end
	end

	read_SliceHeader.se_idx_9_loop : action ==>
	guard
		se_idx = 9 and isFifoFull(fifo), cnt_i < slice_segment_header_extension_length
	var
		uint(size=32) res[1]
	do
		vld_u_name(  8, fifo, res, "slice_segment_header_extension_data_byte");
	end

	read_SliceHeader.se_idx_9_endLoop : action ==>
	guard
		se_idx = 9 and isFifoFull(fifo), cnt_i = slice_segment_header_extension_length
	do
		cnt_i := 0;
		se_idx := 100;
	end

	uint totalByPass := 0;

		read_SliceHeader_done : action ==>
		StrongIntraSmoothing:[sps_strong_intra_smoothing_enable_flag[sps_id], pps_constrained_intra_pred_flag[pps_id]]
	guard
		se_idx = 100
	do
		if DEBUG_CABAC or CHECK_CABAC then
			println("\tPOC: "+poc);
		end
		totalByPass := 0;
		if num_entry_point_offsets > 0 and TILE_SPLIT_ENABLE != 0 then //bypass
			if TilesInfo[1] != 0 then
				byte_align(fifo);
				foreach int k in 0 .. TilesInfo[1] - 1 do
					totalByPass := totalByPass + entryOffsetsTab[k];
				end
			end
		end
	end

	/**************************************************************************
	 **************************************************************************
	 ********        Slice Data                           *********************
	 **************************************************************************
	 *************************************************************************/
	

	/**************************************************************************
	 * read_SliceData.init
	 *************************************************************************/
	//bool          isNotFirstSlice := (first_slice_segment_in_pic_flag = 0);
	
	uint(size=16) colTileInPix[MAX_NUM_TILES] := [0 : for int i in 0 .. MAX_NUM_TILES -1];
	uint(size=16) rowTileInPix[MAX_NUM_TILES] := [0 : for int i in 0 .. MAX_NUM_TILES -1];
	uint(size=16) colWidth[PICT_WIDTH / MIN_CTB_SIZE_Y];
	uint(size=16) rowHeight[PICT_HEIGHT / MIN_CTB_SIZE_Y];

		
	/**************************************************************************
	 **************************************************************************
	 ********        schedule                             *********************
	 **************************************************************************
	 *************************************************************************/
	schedule fsm start_code:
		// byte align
		byte_align          			( byte_align_a						) --> start_code;
		// search start code
		start_code          			( start_code.search					) --> start_code;
		start_code			            ( start_code.done					) --> read_Nal_unit_header;
		// read Nal Unit header
		read_Nal_unit_header			( read_nal_unit_header				) --> find_header;
		find_header	  					( look_for.VPS_header	  			) --> read_VPS_Header;
		find_header	  					( look_for.SEI_header	  			) --> read_SEI_Header;
		find_header	  					( look_for.SPS_header	  			) --> read_SPS_Header;
		find_header	  					( look_for.PPS_header	  			) --> read_PPS_Header;
		find_header	  					( look_for.Slice_header	  			) --> read_SliceHeader;
		// read VPS header
		read_VPS_Header	  				( read_VPS_Header	    			) --> read_VPS_Header;
		read_VPS_Header	  				( read_VPS_Header_done    			) --> byte_align;
		// read SEI header
		read_SEI_Header	  				( read_SEI_Header	    			) --> read_SEI_Header;
		read_SEI_Header	  				( read_SEI_Header_done    			) --> byte_align;
		// read SPS header
		read_SPS_Header	  				( read_SPS_Header	    			) --> read_SPS_Header;
		read_SPS_Header	  				( read_SPS_Header_done    			) --> byte_align;
		// read PPS header
		read_PPS_Header 				( read_PPS_Header   				) --> read_PPS_Header;
		read_PPS_Header	  				( read_PPS_Header_done    			) --> byte_align;
		// read_SliceHeader
		read_SliceHeader				( read_SliceHeader					) --> read_SliceHeader;
		read_SliceHeader				( read_SliceHeader_done				) --> byte_align;
		
		find_header                     ( look_for_other_header             ) --> byte_align;
	end

	/**************************************************************************
	 * priority
	 *************************************************************************/
	priority
		look_for        > look_for_other_header;
	end
end
