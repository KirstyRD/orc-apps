/*
 * Copyright (c) 2012, EPFL
 * All rights reserved.
 * 
 * Redistribution and use in source and binary forms, with or without
 * modification, are permitted provided that the following conditions are met:
 * 
 *   * Redistributions of source code must retain the above copyright notice,
 *     this list of conditions and the following disclaimer.
 *   * Redistributions in binary form must reproduce the above copyright notice,
 *     this list of conditions and the following disclaimer in the documentation
 *     and/or other materials provided with the distribution.
 *   * Neither the name of the EPFL nor the names of its
 *     contributors may be used to endorse or promote products derived from this
 *     software without specific prior written permission.
 * 
 * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
 * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
 * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
 * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
 * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
 * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
 * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
 * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN CONTRACT,
 * STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY
 * WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF
 * SUCH DAMAGE.
 */
package org.ietr.mpegh.part2.main.Filters;

import std.util.Math.*;
import devel.org.sc29.wg11.mpegh.part2.common.CommonConstantHEVC.*;

//There should be much less division.
//There should be a function for the code which test if two pixels are in the same slice thanks to the variable filtAcrSlc.
actor SaoFilterChroma()
	uint(size=2)  IsPicSlcLcu,
	uint(size=8)  LcuSizeMax,
	uint(size=2)  LFAcrossSlcTile,
	uint(size=16) PicSize,
	uint(size=8)  SampleIn,
	int (size=9)  SaoSe,
	uint(size=16) TilesCoord
		==>
	uint(size=8)  FiltSample
		:
		
	bool DEBUG_Trace = false;
		
	uint(size=4)  BIT_DEPTH = 8;


	int(size=3) constHPos0[4][2] = [[-1,1],  [ 0,0], [-1,1],  [ 1,-1]];
	int(size=3) constVPos0[4][2] = [[ 0,0],  [-1,1], [-1,1],  [-1, 1]];
	int(size=3) edgeIdxConv[5] = [1, 2, 0, 3, 4];

	int(size=2) signResult[128][128];

	bool          slcSaoCompEn[3];

	uint(size=8) OrigPict[PICT_HEIGHT][PICT_WIDTH];
	uint(size=8) FiltPict[PICT_HEIGHT][PICT_WIDTH];

	uint(size=2)  saoTypeIdx[PICT_WIDTH/64][PICT_HEIGHT/64];
	int (size=9)  saoOffset[PICT_WIDTH/64][PICT_HEIGHT/64][5];
	uint(size=2)  saoEoClass[PICT_WIDTH/64][PICT_HEIGHT/64];
	uint(size=5)  saoLeftClass[PICT_WIDTH/64][PICT_HEIGHT/64];
	uint(size=3)  bandTable[32];
	uint(size=8)  lcuSizeMax;
	uint(size=8)  log2LcuSizeMax;
	uint(size=6)  picSizeInCu[2];
	uint(size=16) picSize[3][2];
	uint(size=8)  xCu := 0;
	uint(size=8)  yCu := 0;
	uint(size=6)  xCuFilt := 0;
	uint(size=6)  yCuFilt := 0;
	uint(size=16) numTokenPerLcu[2];

	int(size=16) iLoop;

	uint(size=16) numTiles;
	uint(size=16) lcuTileIdx;
	uint(size=16) tilesBeg[MAX_NUM_TILES][2];
	uint(size=16) tilesEnd[MAX_NUM_TILES][2];
	bool         filtAcrSlc[PICT_WIDTH/64][PICT_HEIGHT/64];
	bool         filtAcrTile[PICT_WIDTH/64][PICT_HEIGHT/64];
    bool         filtAcrAllSlc;
	bool         filtAcrAllTiles;
	bool         filtAcrCurrSlc;
	bool         filtAcrCurrTile;
	uint(size=8) numSlc[PICT_WIDTH/64][PICT_HEIGHT/64];
	uint(size=8) numTile[PICT_WIDTH/64][PICT_HEIGHT/64];
    bool         cuFiltered[(PICT_WIDTH + 15)/16 + 1][(PICT_HEIGHT + 15)/16];
	uint(size=8) numCurrSlc;

	procedure sendFilteredLcu(uint xCu, uint yCu)
	begin
		cuFiltered[xCu][yCu] := true;
	end

	procedure nextLcuAddress()
	begin
		xCu := xCu + 1;
		if(xCu = tilesEnd[lcuTileIdx][0]) then
			xCu := tilesBeg[lcuTileIdx][0];
			yCu := yCu + 1;
			if(yCu = tilesEnd[lcuTileIdx][1]) then
				lcuTileIdx := lcuTileIdx + 1;
				xCu := tilesBeg[lcuTileIdx][0];
				yCu := tilesBeg[lcuTileIdx][1];
			end
		end
	end

	procedure nextCuAddr()
	begin
		xCu := xCu + 1;
		if(xCu = picSizeInCu[0]) then
			xCu := 0;
			yCu := yCu + 1;
		end
	end

	function lcuFiltIsPictureBorder() --> bool
	:
		xCuFilt = 0 || yCuFilt = 0||
		xCuFilt+1 >= picSizeInCu[0] ||
		yCuFilt+1 >= picSizeInCu[1]
	end

	procedure copyCu(uint(size=16) addrBeg[2], uint(size=16) addrEnd[2])
	begin
		foreach int y in addrBeg[1] .. addrEnd[1]
		do
			foreach int x in addrBeg[0] .. addrEnd[0]
			do
				FiltPict[y][x] := OrigPict[y][x];
			end
		end
	end

    @optimize_c(condition="OPENHEVC_ENABLE", name="saoFilterEdge_orcc")
	procedure saoFilterEdge(uint(size=2) saoEoClasss, uint(size=8) cIdx, uint(size=8) cIdxOffset,
		uint(size=16) idxMin[2], uint(size=8) lcuSizeMax, uint(size=16) picSize[2],
		bool lcuIsPictBorder, 
		int(size=32) saoOff[5], bool filtAcrossSlcAndTiles,
		uint(size=8) OrigPict[PICT_HEIGHT][PICT_WIDTH],
		uint(size=8) FiltPict[PICT_HEIGHT][PICT_WIDTH])
	begin
		if(saoEoClass[xCuFilt][yCuFilt] = 0) then
			saoFilterEdgeChroma_Horiz(idxMin[0], idxMin[1], picSize, lcuIsPictBorder);
		else if(saoEoClass[xCuFilt][yCuFilt] = 1) then
			saoFilterEdgeChroma_Vert(idxMin[0], idxMin[1], picSize, lcuIsPictBorder);
		else
			saoFilterEdgeChroma_Diag(idxMin[0], idxMin[1], picSize, lcuIsPictBorder);
		end end
	end

	procedure saoFilterEdgeChroma_Horiz(uint(size=16) rx, uint(size=16) ry,
		uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) xPix1,
		uint(size=16) xPix2,
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		int(size=2) sign3Result
	begin
		foreach uint(size=3) y in 0 .. (lcuSizeMax - 1) >> 1
		do
			yIdx := ry + y;
			foreach uint(size=3) x in 0 .. (lcuSizeMax - 1) >> 1
			do
				xIdx := rx + x;
				if(not lcuIsPictBorder || xIdx<picSize[0] && yIdx<picSize[1]) then
					xPix1 := xIdx - 1;
					xPix2 := xIdx + 1;

					pixIsInPict := true;
					if(lcuIsPictBorder && (xPix1 >= picSize[0] ||
						xPix2 >= picSize[0])) then
						pixIsInPict := false;
					//if xPix1 and xPix2 are in the same slice, then
					//the 3 pixels used for the Sao are in the same slice.
					else if(not filtAcrSlc[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] &&
						numSlc[xPix1 >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] !=
						numSlc[xPix2 >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)]) then
						pixIsInPict := false;
					else if(not filtAcrTile[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] &&
						numTile[xPix1 >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] !=
						numTile[xPix2 >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)]) then
						pixIsInPict := false;
					end end end

					if(pixIsInPict) then
						edgeIdx := 2;
						if(x=0) then
							sign3Result := Sign3(OrigPict[yIdx][xIdx] -
								OrigPict[yIdx][xPix1]);
						end
						edgeIdx := edgeIdx + sign3Result;

						sign3Result := Sign3(OrigPict[yIdx][xIdx] -
								OrigPict[yIdx][xPix2]);
						edgeIdx := edgeIdx + sign3Result;

						edgeIdx := edgeIdxConv[edgeIdx];
						//Saving the value to avoid computing it again and Sign3(B-A) = -Sign3(A-B)
						sign3Result := -sign3Result;
					else
						edgeIdx := 0;
						sign3Result := Sign3(OrigPict[yIdx][xPix2] -
							OrigPict[yIdx][xIdx]);
					end
					FiltPict[yIdx][xIdx] := clip_i32(OrigPict[yIdx][xIdx] +
						saoOffset[xCuFilt][yCuFilt][edgeIdx], 0, 255);
				end
			end
		end
	end

	procedure saoFilterEdgeChroma_Vert(uint(size=16) rx, uint(size=16) ry,
		uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		uint(size=16) xIdx,
		uint(size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		int(size=2) sign3Result
	begin
		foreach uint(size=3) x in 0 .. (lcuSizeMax - 1) >> 1
		do
			xIdx := rx + x;
			foreach uint(size=3) y in 0 .. (lcuSizeMax - 1) >> 1
			do
				yIdx := ry + y;
				if(not lcuIsPictBorder || xIdx<picSize[0] && yIdx<picSize[1]) then
					pixIdx[0][1] := yIdx - 1;
					pixIdx[1][1] := yIdx + 1;

					pixIsInPict := true;
					if(lcuIsPictBorder && (pixIdx[0][1]>=picSize[1] ||
						pixIdx[1][1]>=picSize[1])) then
						pixIsInPict := false;
					//if yPix1 and yPix2 are in the same slice, then
					//the 3 pixels used for the Sao are in the same slice.
					else if(not filtAcrSlc[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] &&
						numSlc[xIdx >> (log2LcuSizeMax - 1)][pixIdx[0][1] >> (log2LcuSizeMax - 1)] !=
						numSlc[xIdx >> (log2LcuSizeMax - 1)][pixIdx[1][1] >> (log2LcuSizeMax - 1)]) then
						pixIsInPict := false;
					else if(not filtAcrTile[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] &&
						numTile[xIdx >> (log2LcuSizeMax - 1)][pixIdx[0][1] >> (log2LcuSizeMax - 1)] !=
						numTile[xIdx >> (log2LcuSizeMax - 1)][pixIdx[1][1] >> (log2LcuSizeMax - 1)]) then
						pixIsInPict := false;
					end end end

					if(pixIsInPict) then
						edgeIdx := 2;
						if(y=0) then
							sign3Result := Sign3(OrigPict[yIdx][xIdx] -
								OrigPict[pixIdx[0][1]][xIdx]);
						end
						edgeIdx := edgeIdx + sign3Result;

						sign3Result := Sign3(OrigPict[yIdx][xIdx] -
								OrigPict[pixIdx[1][1]][xIdx]);
						edgeIdx := edgeIdx + sign3Result;

						edgeIdx := edgeIdxConv[edgeIdx];
						//Saving the value to avoid computing it again and Sign3(B-A) = -Sign3(A-B)
						sign3Result := -sign3Result;
					else
						edgeIdx := 0;
						sign3Result := Sign3(OrigPict[pixIdx[1][1]][xIdx] -
							OrigPict[yIdx][xIdx]);
					end
					FiltPict[yIdx][xIdx] := clip_i32(OrigPict[yIdx][xIdx] +
						saoOffset[xCuFilt][yCuFilt][edgeIdx], 0, 255);
				end		
			end
		end
	end

	procedure saoFilterEdgeChroma_Diag(uint(size=16) rx, uint(size=16) ry, 
		uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		int (size=16) xIdx,
		int (size=16) yIdx,
		uint(size=16) pixIdx[2][2],
		bool pixIsInPict,
		uint(size=3) edgeIdx,
		uint(size=3) bandShift = BIT_DEPTH-5,
		uint(size=3) bandIdx,
		int(size=2) sign3Result,
		int(size=2)  xOff[2],
		int(size=2)  yOff[2]
	begin
		foreach uint k in 0 .. 1
			do
				xOff[k] := constHPos0[saoEoClass[xCuFilt][yCuFilt]][k];
				yOff[k] := constVPos0[saoEoClass[xCuFilt][yCuFilt]][k];
			end
			foreach uint(size=3) y in 0 .. (lcuSizeMax - 1) >> 1
			do
				yIdx := ry + y;
				foreach uint(size=3) x in 0 .. (lcuSizeMax - 1) >> 1
				do
					xIdx := rx + x;
					if(not lcuIsPictBorder || xIdx<picSize[0] && yIdx<picSize[1]) then
						if(saoTypeIdx[xCuFilt][yCuFilt] = 2) then
							pixIsInPict := true;
							foreach uint k in 0 .. 1
							do
								pixIdx[k][0] := xIdx + xOff[k];
								pixIdx[k][1] := yIdx + yOff[k];
								if(lcuIsPictBorder &&
									(pixIdx[k][0] >= picSize[0] ||
									pixIdx[k][1]>=picSize[1])) then
									pixIsInPict := false;
								else if(not filtAcrSlc[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] &&
									numSlc[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] !=
									numSlc[pixIdx[k][0] >> (log2LcuSizeMax - 1)][pixIdx[k][1] >> (log2LcuSizeMax - 1)]) then
									pixIsInPict := false;
								else if(not filtAcrTile[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] &&
									numTile[xIdx >> (log2LcuSizeMax - 1)][yIdx >> (log2LcuSizeMax - 1)] !=
									numTile[pixIdx[k][0] >> (log2LcuSizeMax - 1)][pixIdx[k][1] >> (log2LcuSizeMax - 1)]) then
									pixIsInPict := false;
								end end end
							end

							if(pixIsInPict) then
								edgeIdx := 2;
								//Check if the value has already been computed.
								if(x=0 || y=0 || x=((lcuSizeMax - 1) >> 1)) then
									sign3Result := Sign3(OrigPict[yIdx][xIdx] -
										OrigPict[pixIdx[0][1]][pixIdx[0][0]]);
								else
									sign3Result := signResult[x][y];
								end
								edgeIdx := edgeIdx + sign3Result;
	
								sign3Result := Sign3(OrigPict[yIdx][xIdx] -
										OrigPict[pixIdx[1][1]][pixIdx[1][0]]);
								edgeIdx := edgeIdx + sign3Result;
	
								//Saving the value to avoid computing it again and Sign3(B-A) = -Sign3(A-B)
								signResult[(x+xOff[1])&127]
									[(y+yOff[1])&127] := -sign3Result;
								edgeIdx := edgeIdxConv[edgeIdx];
							else
								edgeIdx := 0;
								signResult[(x+xOff[1])&127]
									[(y+yOff[1])&127] :=
									Sign3(OrigPict[pixIdx[1][1]][pixIdx[1][0] & MASK_WIDTH_POW_2] -
										OrigPict[yIdx][xIdx]);
							end
							FiltPict[yIdx][xIdx] := clip_i32(OrigPict[yIdx][xIdx] +
								saoOffset[xCuFilt][yCuFilt][edgeIdx], 0, 255);
						else
							bandIdx := bandTable[OrigPict[yIdx][xIdx]>>bandShift];
							FiltPict[yIdx][xIdx] := clip_i32(OrigPict[yIdx][xIdx] +
								saoOffset[xCuFilt][yCuFilt][bandIdx], 0, 255);
						end
					end		
				end
			end
	end
	
	@optimize_c(condition="OPENHEVC_ENABLE", name="saoBandFilter_orcc")
	procedure saoBandFilter(uint(size=5) saoLeftClass, int(size=32) saoOffset[5],
		uint(size=2) cIdx, uint(size=8) cIdxOffset, int (size=16) idxMin[2], int (size=16) idxMax[2],
		uint(size=8) OrigPict[PICT_HEIGHT][PICT_WIDTH],
		uint(size=8) FiltPict[PICT_HEIGHT][PICT_WIDTH])
	var
		uint(size=3)  bandShift = BIT_DEPTH-5,
		uint(size=3)  bandIdx,
		uint(size=3)  bandTable[32] := [0: for int i in 0 .. 31]
	begin
		foreach uint k in 0 .. 3
		do
			bandTable[(k+saoLeftClass) & 31] := k+1;
		end
		foreach uint(size=16) y in idxMin[1] .. idxMax[1]
		do
			foreach int(size=16) x in idxMin[0] .. idxMax[0]
			do
				bandIdx := bandTable[OrigPict[y][x]>>bandShift];
				FiltPict[y][x] :=
					clip_i32(OrigPict[y][x] +
					saoOffset[bandIdx], 0, 255);
			end
		end
	end
	
	procedure codingTreeBlockModif(uint(size=16) rx, uint(size=16) ry, 
		uint(size=16) picSize[2], bool lcuIsPictBorder)
	var
		int (size=16) idxMax[2],
		int (size=16) idxOrig[2] = [rx, ry],
		int (size=32) saoOff[5]
	begin
		saoOff := [saoOffset[xCuFilt][yCuFilt][i]: for int i in 0 .. 4];
		if(saoTypeIdx[xCuFilt][yCuFilt] = 2) then

			saoFilterEdge(saoEoClass[xCuFilt][yCuFilt], 1, 0, idxOrig, lcuSizeMax / 2, picSize, lcuIsPictBorder,
				saoOff, filtAcrAllSlc
				&&filtAcrAllTiles, OrigPict, FiltPict);
		else
			idxMax[0] := min((lcuSizeMax - 1), picSize[0] - rx - 1) + rx;
			idxMax[1] := min((lcuSizeMax - 1), picSize[1] - ry - 1) + ry;
			saoBandFilter(saoLeftClass[xCuFilt][yCuFilt], saoOff, 1, 0, 
				idxOrig, idxMax, OrigPict, FiltPict);
		end
	end

	procedure filtPrevLcu()
	begin
		// sao band filtering
		if (saoTypeIdx[xCu][yCu] = 1) then
		    xCuFilt := xCu;
		    yCuFilt := yCu;
		    sampAdapOffFilt();
		end
		// Sao edge hor
		if (saoTypeIdx[xCu - 1][yCu] = 2 &&
		  saoEoClass[xCu - 1][yCu] = 0) then
		    xCuFilt := xCu - 1;
		    yCuFilt := yCu;
			sampAdapOffFilt();
		end
		// Sao edge vert or diag2
		if (saoTypeIdx[xCu][yCu - 1] = 2 &&
		  saoEoClass[xCu][yCu - 1] = 1) then
			xCuFilt := xCu;
		    yCuFilt := yCu - 1;
			sampAdapOffFilt();
		end
		// Sao edge diag1
		if (saoTypeIdx[xCu - 1][yCu - 1] = 2 &&
		  (saoEoClass[xCu - 1][yCu - 1] = 2 ||
		  saoEoClass[xCu - 1][yCu - 1] = 3)) then
			xCuFilt := xCu - 1;
			yCuFilt := yCu - 1;
			sampAdapOffFilt();
		end
		// Filtering picture border which haven't already been filtered.
		if (xCu = picSizeInCu[0] -1 && yCu > 0 and not cuFiltered[xCu][yCu-1]) then
			xCuFilt := xCu;
			yCuFilt := yCu - 1;
			sampAdapOffFilt();
		end
		if (xCu > 0 && yCu = picSizeInCu[1] -1 and not cuFiltered[xCu-1][yCu]) then
			xCuFilt := xCu - 1;
			yCuFilt := yCu;
			sampAdapOffFilt();
		end
	end

	procedure sampAdapOffFilt()
	var
		uint(size=16) picSizeLoc[2],
		bool lcuIsPictBorder
	begin
		lcuIsPictBorder := lcuFiltIsPictureBorder();
		sendFilteredLcu(xCuFilt, yCuFilt);
			picSizeLoc := [picSize[1][0], picSize[1][1]];
            if(saoTypeIdx[xCuFilt][yCuFilt] = 1) then
				foreach uint i in 0 .. 31
				do
					bandTable[i] := 0;
				end
				foreach uint k in 0 .. 3
				do
					bandTable[(k+saoLeftClass[xCuFilt][yCuFilt]) & 31] := k+1;
				end
			end
		if(saoTypeIdx[xCuFilt][yCuFilt]!=0) then
			codingTreeBlockModif(xCuFilt << (log2LcuSizeMax - 1),
				(yCuFilt << (log2LcuSizeMax - 1)), picSizeLoc, lcuIsPictBorder);
		end
	end

uint numPict;
	isNewPict: action IsPicSlcLcu:[isNewPicSlcLcu],
		LcuSizeMax:[log2LcuSz], LFAcrossSlcTile:[lfAcrossSlcTile],
		PicSize:[picWidthInPix, picHeightInPix], SaoSe:[saoSe] ==>
	guard
		isNewPicSlcLcu = NEW_PIC
	do
		numPict := numPict + 1;
		log2LcuSizeMax := log2LcuSz;
		lcuSizeMax := 1 << log2LcuSz;
		picSizeInCu := [(picWidthInPix+(lcuSizeMax - 1)) >> log2LcuSizeMax, (picHeightInPix+(lcuSizeMax - 1)) >> log2LcuSizeMax];
		picSize[0]  := [picWidthInPix, picHeightInPix];
		picSize[1]  := [picSize[0][0] >> 1, picSize[0][1] >> 1];
		picSize[2]  := [picSize[1][0], picSize[1][1]];
		slcSaoCompEn[0] := (saoSe & 1) !=0;
		slcSaoCompEn[1] := (saoSe & 2) !=0;
		slcSaoCompEn[2] := slcSaoCompEn[1];
		filtAcrCurrSlc  := (lfAcrossSlcTile & 1) != 0;
		filtAcrCurrTile := (lfAcrossSlcTile & 2) != 0;
		filtAcrAllSlc := filtAcrCurrSlc;
		filtAcrAllTiles := filtAcrCurrTile;
		numCurrSlc := 0;
		lcuTileIdx := 0;
		numTokenPerLcu[0] := lcuSizeMax * lcuSizeMax;
		numTokenPerLcu[1] := numTokenPerLcu[0] >> 2;
        xCuFilt := 0;
		yCuFilt := 0;
		xCu := 0;
		yCu := 0;
		foreach int i in 0 .. picSizeInCu[0] - 1
		do
			foreach int j in 0 .. picSizeInCu[1] - 1
			do
				cuFiltered[i][j] := false;
			end
		end
	end

	//There should be slice SAO enable for each independent slice.
	isNewSlice: action IsPicSlcLcu:[isNewPicSlcLcu],
		LcuSizeMax:[log2LcuSz], LFAcrossSlcTile:[lfAcrossSlcTile],
		PicSize:[picWidthInPix, picHeightInPix]/*, SaoSe:[saoSe]*/ ==>
	guard
		isNewPicSlcLcu = NEW_SLC
	do
        /*slcSaoCompEn[0] := (saoSe & 1) !=0;
		slcSaoCompEn[1] := (saoSe & 2) !=0;
		slcSaoCompEn[2] := slcSaoCompEn[1];*/
		filtAcrCurrSlc  := (lfAcrossSlcTile & 1) != 0;
		filtAcrCurrTile := (lfAcrossSlcTile & 2) != 0;
		filtAcrAllSlc := filtAcrAllSlc && filtAcrCurrSlc;
		filtAcrAllTiles := filtAcrAllTiles && filtAcrCurrTile;
		numCurrSlc := numCurrSlc + 1;
		log2LcuSizeMax := log2LcuSz;
		lcuSizeMax := 1 << log2LcuSz;
	end

	getNumTiles: action TilesCoord:[valNumTiles] ==>
	do
		numTiles := valNumTiles;
		iLoop := 0;
	end

	getTilesCoord.launch: action TilesCoord:[tilesCoord] repeat 4 ==>
	guard
		iLoop < numTiles
	do
		tilesBeg[iLoop] := [tilesCoord[0] >> log2LcuSizeMax, tilesCoord[1] >> log2LcuSizeMax];
		tilesEnd[iLoop] := [(tilesCoord[2]+(lcuSizeMax - 1)) >> log2LcuSizeMax, (tilesCoord[3]+(lcuSizeMax - 1)) >> log2LcuSizeMax];
		iLoop := iLoop + 1;
	end

	getTilesCoord.done: action ==>
	guard
		iLoop = numTiles
	end

    checkSliceEn.isFalse: action ==>
	guard
		not slcSaoCompEn[0] && not slcSaoCompEn[1]
	end

	checkSliceEn.isTrue: action ==>
	guard
		slcSaoCompEn[0] || slcSaoCompEn[1]
	end
	getCuPix.launch.init.x64: action IsPicSlcLcu:[isNewLcu], SampleIn:[samp] repeat 32*32 ==>
	guard
		lcuTileIdx < numTiles, lcuSizeMax = 64
	do
		foreach int y in 0 .. 31
		do
			foreach int x in 0 .. 31
			do
				OrigPict[(yCu * lcuSizeMax/2) + y][(xCu * lcuSizeMax/2) + x] := samp[32*y + x];
			end
		end
		
		numSlc[xCu][yCu]  := numCurrSlc;
		numTile[xCu][yCu] := lcuTileIdx;
		filtAcrSlc[xCu][yCu]  := filtAcrCurrSlc;
		filtAcrTile[xCu][yCu] := filtAcrCurrTile;
	end
	
	getCuPix.launch.init.x32: action IsPicSlcLcu:[isNewLcu], SampleIn:[samp] repeat 16*16 ==>
	guard
		lcuTileIdx < numTiles, lcuSizeMax = 32
	do
		foreach int y in 0 .. 15
		do
			foreach int x in 0 .. 15
			do
				OrigPict[(yCu * lcuSizeMax/2) + y][(xCu * lcuSizeMax/2) + x] := samp[16*y + x];
			end
		end
		
		numSlc[xCu][yCu]  := numCurrSlc;
		numTile[xCu][yCu] := lcuTileIdx;
		filtAcrSlc[xCu][yCu]  := filtAcrCurrSlc;
		filtAcrTile[xCu][yCu] := filtAcrCurrTile;
	end
	
	getCuPix.launch.init.x16: action IsPicSlcLcu:[isNewLcu], SampleIn:[samp] repeat 8*8 ==>
	guard
		lcuTileIdx < numTiles, lcuSizeMax = 16
	do
		foreach int y in 0 .. 7
		do
			foreach int x in 0 .. 7
			do
				OrigPict[(yCu * lcuSizeMax/2) + y][(xCu * lcuSizeMax/2) + x] := samp[8*y + x];
			end
		end
		
		numSlc[xCu][yCu]  := numCurrSlc;
		numTile[xCu][yCu] := lcuTileIdx;
		filtAcrSlc[xCu][yCu]  := filtAcrCurrSlc;
		filtAcrTile[xCu][yCu] := filtAcrCurrTile;
	end

	getCuPix.done: action ==>
	guard
		lcuTileIdx = numTiles
	do
		xCuFilt := picSizeInCu[0] -1;
		yCuFilt := picSizeInCu[1] -1;
		if (not cuFiltered[xCuFilt][yCuFilt]) then
		  sampAdapOffFilt();
	    end
	end

	getSaoMerge.noMerge: action SaoSe:[mergeInfo] ==>
	guard
		mergeInfo = SAO_NO_MERGE
	do
		if (DEBUG_Trace) then
			println("=== getSaoMerge.noMerge ===");
			println("SaoSe       = " + mergeInfo);
		end
	end

	getSaoMerge.merge: action SaoSe:[mergeInfo] ==>
	guard
		mergeInfo != SAO_NO_MERGE
	var
		uint(size=16) addrBeg[2],
		uint(size=16) addrEnd[2],
		uint(size=16) xMerge =
			if(mergeInfo = SAO_MERGE_LEFT) then xCu-1 else xCu end,
		uint(size=16) yMerge =
			if(mergeInfo = SAO_MERGE_UP)  then yCu-1 else yCu end
	do
		if (DEBUG_Trace) then
			println("=== getSaoMerge.Merge ===");
			println("SaoSe       = " + mergeInfo);
		end
		
		saoTypeIdx[xCu][yCu] := saoTypeIdx[xMerge][yMerge];
		if(saoTypeIdx[xCu][yCu] = 0) then
			addrBeg :=
					[xCu * (lcuSizeMax >> 1), yCu * (lcuSizeMax >> 1)];
			addrEnd :=
					[(xCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1), (yCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1)];
	
			copyCu(addrBeg, addrEnd);
            sendFilteredLcu(xCu, yCu);
		else
			foreach uint i in 1 .. 4
			do
				saoOffset[xCu][yCu][i] := saoOffset[xMerge][yMerge][i];
			end
			saoEoClass[xCu][yCu] := saoEoClass[xMerge][yMerge];
			saoLeftClass[xCu][yCu] := saoLeftClass[xMerge][yMerge];
		end
		filtPrevLcu();
		nextLcuAddress();
	end

	getSaoMerge.skip: action ==>
	var
		uint(size=16) addrBeg[2],
		uint(size=16) addrEnd[2]
	do
		saoTypeIdx[xCu][yCu] := 0;

		addrBeg := [xCu * (lcuSizeMax >> 1), yCu * (lcuSizeMax >> 1)];
		addrEnd := [(xCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1),
		        (yCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1)];
		copyCu(addrBeg, addrEnd);
        sendFilteredLcu(xCu, yCu);

		nextLcuAddress();
	end

	getSaoTypeIdx.is0: action SaoSe:[typeIdx] ==>
	guard
		slcSaoCompEn[1] && typeIdx = 0
	var
		uint(size=16) addrBeg[2],
		uint(size=16) addrEnd[2]
	do
		if (DEBUG_Trace) then
			println("=== getSaoTypeIdx.is0 ===");
			println("SaoSe       = " + typeIdx);
		end
		
		addrBeg :=
				[xCu * (lcuSizeMax >> 1), yCu * (lcuSizeMax >> 1)];
		addrEnd :=
				[(xCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1),
					(yCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1)];

		copyCu(addrBeg, addrEnd);
        sendFilteredLcu(xCu, yCu);
		
		saoTypeIdx[xCu][yCu] := 0;
	end

	getSaoTypeIdx.isNot0: action SaoSe:[saoSe] repeat 6 ==>
	guard
		slcSaoCompEn[1] && saoSe[0] != 0
	do
		if (DEBUG_Trace) then
			println("=== getSaoTypeIdx.isNot0 ===");
			print("SaoSe       = [");
			foreach uint i in 0 .. 5 do
				print(saoSe[i] + ", ");
			end
			println("]");
		end
		
		saoTypeIdx[xCu][yCu] := saoSe[0];
		foreach uint i in 1 .. 4
		do
			saoOffset[xCu][yCu][i] := saoSe[i];
		end
		if(saoTypeIdx[xCu][yCu]=2) then
			saoEoClass[xCu][yCu] := saoSe[5];
		else
			saoLeftClass[xCu][yCu] := saoSe[5];
		end

	end

	getSaoTypeIdx.skip: action ==>
	guard
		not slcSaoCompEn[1]
	var
		uint(size=16) addrBeg[2],
		uint(size=16) addrEnd[2]
	do
		addrBeg :=
				[xCu * (lcuSizeMax >> 1), yCu * (lcuSizeMax >> 1)];
		addrEnd :=
				[(xCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1), (yCu * (lcuSizeMax >> 1))+ ((lcuSizeMax - 1) >> 1)];

		saoTypeIdx[xCu][yCu] := 0;
		copyCu(addrBeg, addrEnd);
        sendFilteredLcu(xCu, yCu);
	end

	getSaoTypeIdxDone: action ==>
	do
		filtPrevLcu();
		nextLcuAddress();
	end

	

	sendSamples.launch.x64: action ==> FiltSample:[filtSamp] repeat 32*32
	guard
      lcuSizeMax = 64
	var
		uint(size=8) filtSamp[32*32],
		uint(size=16) blkAddrX, uint(size=16) blkAddrY
	do
		blkAddrX := xCu*64;
		blkAddrY := yCu*64;

		blkAddrX := blkAddrX>>1;
		blkAddrY := blkAddrY>>1;
		foreach uint y in 0 .. 31
		do
			foreach uint x in 0 .. 31
			do
				filtSamp[x+y*32] := FiltPict[blkAddrY+y][blkAddrX+x];
			end
		end

		nextCuAddr();
	end
	
	sendSamples.launch.x32: action ==> FiltSample:[filtSamp] repeat 16*16
	guard
		lcuSizeMax = 32
	var
		uint(size=8) filtSamp[16*16],
		uint(size=16) blkAddrX, uint(size=16) blkAddrY
	do
		blkAddrX := xCu*32;
		blkAddrY := yCu*32;

		blkAddrX := blkAddrX>>1;
		blkAddrY := blkAddrY>>1;
		foreach uint y in 0 .. 15
		do
			foreach uint x in 0 .. 15
			do
				filtSamp[x+y*16] := FiltPict[blkAddrY+y][blkAddrX+x];
			end
		end

 	    nextCuAddr();
	end
	
	sendSamples.launch.x16: action ==> FiltSample:[filtSamp] repeat 8*8
	guard
      lcuSizeMax = 16
	var
		uint(size=8) filtSamp[8*8],
		uint(size=16) blkAddrX, uint(size=16) blkAddrY
	do
		blkAddrX := xCu*16;
		blkAddrY := yCu*16;

		blkAddrX := blkAddrX>>1;
		blkAddrY := blkAddrY>>1;
		foreach uint y in 0 .. 7
		do
			foreach uint x in 0 .. 7
			do
				filtSamp[x+y*8] := FiltPict[blkAddrY+y][blkAddrX+x];
			end
		end

		nextCuAddr();
	end

	sendSamples.done: action ==>
	guard
		not cuFiltered[xCu][yCu] ||
		yCu = picSizeInCu[1]
	end

	schedule fsm IsNewPict:
		IsNewPict     (isNewPict     )--> CheckSliceEn;

        CheckSliceEn (checkSliceEn.isTrue )-->GetNumTilesFilt;
		CheckSliceEn (checkSliceEn.isFalse )-->GetNumTilesSkipFilt;

        /* Using SAO */
		GetCuPixFilt (isNewSlice           )--> GetNumTilesFilt;
		GetCuPixFilt (getCuPix.launch.init )--> GetSaoMergeFilt;
		GetCuPixFilt (getCuPix.done        )--> SendLastSamplesFilt;

		GetNumTilesFilt   (getNumTiles          )--> GetTilesCoordFilt;
		GetTilesCoordFilt (getTilesCoord.launch )--> GetTilesCoordFilt;
		GetTilesCoordFilt (getTilesCoord.done   )--> GetCuPixFilt;

		GetSaoMergeFilt (getSaoMerge.merge   )--> SendSamplesFilt;
		GetSaoMergeFilt (getSaoMerge.noMerge )--> GetSaoTypeIdxFilt;

		GetSaoTypeIdxFilt (getSaoTypeIdx     )--> GetSaoTypeIdxFiltDone;
		GetSaoTypeIdxFiltDone (getSaoTypeIdxDone )--> SendSamplesFilt;

		SendSamplesFilt (sendSamples.launch )--> SendSamplesFilt;
		SendSamplesFilt (sendSamples.done   )--> GetCuPixFilt;

		SendLastSamplesFilt (sendSamples.launch )--> SendLastSamplesFilt;
        SendLastSamplesFilt (sendSamples.done   )--> IsNewPict;

        /* Not using SAO. */
        GetCuPixSkipFilt (isNewSlice           )--> GetNumTilesSkipFilt;
		GetCuPixSkipFilt (getCuPix.launch.init )--> GetSaoMergeSkipFilt;
		GetCuPixSkipFilt (getCuPix.done        )--> SendLastSamplesSkipFilt;
        GetNumTilesSkipFilt   (getNumTiles          )--> GetTilesCoordSkipFilt;
		GetTilesCoordSkipFilt (getTilesCoord.launch )--> GetTilesCoordSkipFilt;
		GetTilesCoordSkipFilt (getTilesCoord.done   )--> GetCuPixSkipFilt;

		GetSaoMergeSkipFilt (getSaoMerge.skip    )--> SendSamplesSkipFilt;

		SendSamplesSkipFilt (sendSamples.launch )--> SendSamplesSkipFilt;
		SendSamplesSkipFilt (sendSamples.done   )--> GetCuPixSkipFilt;

		SendLastSamplesSkipFilt (sendSamples.launch )--> SendLastSamplesSkipFilt;
		SendLastSamplesSkipFilt (sendSamples.done   )--> IsNewPict;
	end
	priority
		sendSamples.done > sendSamples.launch;
		isNewSlice > getCuPix.launch.init;
	end
end
